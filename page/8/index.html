<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>mLiXin&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Be true to yourself.">
<meta property="og:type" content="website">
<meta property="og:title" content="mLiXin&#39;s Blog">
<meta property="og:url" content="http://yoursite.com/page/8/index.html">
<meta property="og:site_name" content="mLiXin&#39;s Blog">
<meta property="og:description" content="Be true to yourself.">
<meta property="article:author" content="mLiXin">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/mLixin.github.io/atom.xml" title="mLiXin&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/mLixin.github.io/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/mLixin.github.io/" id="logo">mLiXin&#39;s Blog</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/mLixin.github.io/" id="subtitle">The truth conquers all.</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/mLixin.github.io/">Home</a>
        
          <a class="main-nav-link" href="/mLixin.github.io/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/mLixin.github.io/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-GeekBang-Android开发高手课" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/" class="article-date">
  <time datetime="2019-01-03T01:37:13.000Z" itemprop="datePublished">2019-01-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">Geek Android开发高手课 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>一遍不行就两遍，看不懂就死磕，一直看不懂就一直死磕。</p>
        
          <p class="article-more-link">
            <a href="/mLixin.github.io/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/" data-id="ck8e3fmsl00hx27qy81bv6479" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/GeekBang/" rel="tag">GeekBang</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-book-设计模式之禅" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/09/28/book-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/" class="article-date">
  <time datetime="2018-09-28T02:29:33.000Z" itemprop="datePublished">2018-09-28</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/09/28/book-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/">设计模式之禅 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="第1、2、3、4、5、6章-六大设计原则"><a href="#第1、2、3、4、5、6章-六大设计原则" class="headerlink" title="第1、2、3、4、5、6章 六大设计原则"></a>第1、2、3、4、5、6章 六大设计原则</h4><ol>
<li><p>6大设计原则都是什么？</p>
<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特原则</li>
<li>开闭原则</li>
</ul>
</li>
<li><p>什么是单一职责原则(Single Responsibility Principle)？</p>
<ul>
<li>应该有且仅有一个原因引起类的变更。(There should never be more than one reason for a class to change.)</li>
</ul>
</li>
<li><p>什么是里氏替换原则(Liskov Substitution Principle)？</p>
<ul>
<li>所有引用基类的地方必须能透明地使用其子类的对象，(Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.).即只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不序言知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类未必就能适应。</li>
<li>4层含义：<ul>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现父类的方法时输入参数可以被放大</li>
<li>覆写或实现父类的方法时输出结果可以被缩小</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是依赖倒置原则(Dependence Inversion Principle)？</p>
<ul>
<li>高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。(High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.)</li>
</ul>
</li>
<li><p>什么是接口隔离原则(Interface Segregation Principle)？</p>
<ul>
<li>建立单一接口，不要建立臃肿庞大的接口。就是接口尽量细化，同时接口中的方法尽量少。</li>
<li>4层含义：<ul>
<li>接口要尽量小</li>
<li>接口要高内聚</li>
<li>定制服务</li>
<li>接口设计是有限度的。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是迪米特原则(Law of Demeter)？</p>
<ul>
<li>一个对象应该对其他对象有最少的了解。就是一个类应该对自己需要耦合或调用的类知道得最少。</li>
<li>四层含义：<ul>
<li>只和朋友交流</li>
<li>朋友间也是有距离的</li>
<li>是自己的就是自己的：如果一个方法放在本类中既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li>
<li>谨慎使用Serializable</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是开闭原则(Open Closed Principle)？</p>
<ul>
<li>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。(Soft entities like classes,modules and funtions should be open for extension but closed for modifycations.)</li>
</ul>
</li>
</ol>
<h4 id="第7章-单例模式"><a href="#第7章-单例模式" class="headerlink" title="第7章 单例模式"></a>第7章 单例模式</h4><ol>
<li><p>单例模式是怎样的？有什么优缺点？</p>
<ul>
<li>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。(Ensure a class has only one instance,and provide a global point of access to it.)</li>
<li>优点：<ul>
<li>减少内存开支；减少系统的性能开销；避免对资源的多重占用；优化和共享资源访问。</li>
</ul>
</li>
<li>缺点：<ul>
<li>扩展困难，只能修改代码实现；与单一职责原则有冲突。</li>
</ul>
</li>
</ul>
</li>
<li><p>懒汉式、懒汉式、双重校验、静态内部类、枚举，这五种单例模式分别是怎样的？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon instance = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckSingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleTon<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckSingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleTon instance = <span class="keyword">new</span> StaticInnerClassSingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleTon &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/28/book-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/" data-id="ck8e3fmn1000r27qyhifig6ho" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/" rel="tag">设计模式之禅</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-GeekBang-数据结构与算法之美" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/09/21/GeekBang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/" class="article-date">
  <time datetime="2018-09-21T02:01:53.000Z" itemprop="datePublished">2018-09-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/09/21/GeekBang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/">Geek 数据结构与算法之美 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="第5讲-数组"><a href="#第5讲-数组" class="headerlink" title="第5讲 数组"></a>第5讲 数组</h4><ol>
<li>什么是数组？<ul>
<li>数组是一种线性表数据结构，它用一组连续的内存空间来存储一组具有相同类型的数据。</li>
<li>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)</li>
</ul>
</li>
<li>那些数据结构是线性表？哪些是非线性表？<ul>
<li>线性表：数组、链表、队列、栈</li>
<li>非线性表：数、图</li>
</ul>
</li>
<li>数组为了保持内存数据的连续性，会导致插入、删除操作比较抵消，为啥？有什么改进方法？<ul>
<li>插入删除后需要移动大量的数据，导致低效</li>
<li>如果数据是有序的，就没办法， 如果数据不是有序的，可以在插入的时候，将原来的数据直接添加到数组尾部；删除的时候，直接将数组尾部的数据添加到当前位置。</li>
</ul>
</li>
<li>Java中的ArrayList和数组相比有什么优势？使用的时候有什么需要注意的点？<ul>
<li>可以将很多数组操作的细节封装起来</li>
<li>支持动态扩容；Java中的ArrayList在存储空间不足的时候，会将空间自动扩容为1.5倍大小。</li>
<li>但是要注意，在扩容的时候涉及内存申请和数据搬移，是比较耗时的，所以如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候指定数据大小。</li>
</ul>
</li>
<li>使用数组和容器比如Java中的ArrayList上有什么需要注意的点？<ul>
<li>Java的ArrayList无法存储基本类型， 比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，如果特别关注性能，或者希望使用基本类型，就可以选用数组</li>
<li>如果数据大小事先一直，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法， 也可以直接使用数组</li>
</ul>
</li>
<li>为什么大多数编程语言中，数组要从0开始编号而不是从1开始？<ul>
<li>从数组存储的内存模型上来看，“下标”最确切的定义应该是“offset”，数组a是用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置。所以从0开始编号的话，每次都能减少一次减法操作，效率的优化做到极致，不过也可能就是历史原因。</li>
</ul>
</li>
<li>JVM的标记清除垃圾回收算法的核心理念是什么？说一下你理解的标记清除垃圾回收算法？<ul>
<li>大部分的虚拟机是采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始</li>
<li>标记和清理的效率都不高，但是在只有少量垃圾产生时才会高效。会产生不连续的内存空间碎片。</li>
</ul>
</li>
<li>二维数组的内存寻址公式是怎样的？<ul>
<li>对于<code>m * n</code>的数组，<code>a[i][j](i&lt;m,j&lt;n)</code>的地址为 <code>address = base_address + (i*n+j)*type_size</code></li>
</ul>
</li>
</ol>
<h4 id="第6、7讲-链表"><a href="#第6、7讲-链表" class="headerlink" title="第6、7讲 链表"></a>第6、7讲 链表</h4><ol>
<li><p>什么是链表</p>
<ul>
<li>链表不需要连续的内存空间，通过“指针”将一组零散的内存卡串联起来。</li>
</ul>
</li>
<li><p>单链表、双向链表、循环链表是怎样的？</p>
<ul>
<li>单链表有两个结点，头结点和尾结点，其中头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表，而尾结点的指针不是指向想一个结点，而是指向一个空地址null，表示这是链表上最后一个节点。</li>
<li>循环链表是一种特殊的单链表，它和单链表唯一的区别是尾结点，循环链表的尾结点指向链表的头结点。约瑟夫问题就可以很简单的通过循环链表解决。</li>
<li>双向链表是支持两个方向，及知道前一个结点的地址，也知道后一个结点的地址。但是双向链表需要额外两个空间来存储后继结点和前驱结点，所以会比单链表占用更多的内存空间。</li>
</ul>
</li>
<li><p>分析删除操作中，删除节点中值等于某个给定值的结点，和删除给定指针指向的结点这两种情况下用哪种链表更好？</p>
<ul>
<li>如果是单链表，两种情况都需要从头开始遍历到指定结点去删除，所以时间复杂度都是O(n);而双向链表在第二种情况下，因为能知道给定结点的前驱指针是哪个，所以第二种情况的时间复杂度是O(1)</li>
</ul>
</li>
<li><p>Java中的LinkedHashMap用到了哪种链表？</p>
<ul>
<li>双向链表</li>
</ul>
</li>
<li><p>用空间换时间是什么意思？举例说明一下</p>
<ul>
<li>当内存空间充足的时候，如果我们更追求代码的执行速度，就可以选择空间复杂度相对较高，但是时间复杂度相对较低的算法或数据结构；相反如果内存比较紧缺，比如代码跑在手机或者单片机上的时候，就要反过来时间换空间了。</li>
<li>换粗就是利用了空间换时间的设计思想。</li>
</ul>
</li>
<li><p>如何基于链表实现LRU缓存淘汰算法？</p>
<ul>
<li>我们维护一个有序单链表，越靠近表尾部的结点是越早之前访问的，当有一个新的数据被访问的时候，我们就从链表头开始遍历链表；<ul>
<li>如果该数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部</li>
<li>如果该数据没有在缓存链表中<ul>
<li>如果缓存未满，直接将此结点直接插入到链表的头部</li>
<li>如果缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么cpu缓存机制使用数组更好？</p>
<ul>
<li>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中，而CPU每次从内存读取数据并不是只读那个特定的地址，而是读一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要在从内存中取。所以就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异。对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把后面几个下标也加载到CPU缓存中，这样执行速度就会快于存储空间不连续的链表存储。</li>
</ul>
</li>
<li><p>如果字符串是通过单链表来存储的，如何判断是一个回文串？解决思路是什么？相应的时间空间复杂度又是什么？</p>
<ul>
<li>快慢指针，一部分反转，然后遍历比较。</li>
</ul>
</li>
<li><p>对于指针如何理解？</p>
<ul>
<li>将某个变量赋值给指针，实际上就是将这个变量的地址复制给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</li>
</ul>
</li>
<li><p>如何利用哨兵简化实现难度？</p>
<ul>
<li>针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。</li>
</ul>
</li>
<li><p>一般检查链表代码是否正确的边界条件有哪几个？</p>
<ol>
<li>如果链表为空时</li>
<li>如果链表只包含一个结点时</li>
<li>如果链表只包含两个结点时</li>
<li>代码逻辑在处理头结点和尾结点时能否正常工作。</li>
</ol>
</li>
</ol>
<h4 id="第8讲-栈"><a href="#第8讲-栈" class="headerlink" title="第8讲 栈"></a>第8讲 栈</h4><ol>
<li><p>如何实现一个栈？</p>
<ul>
<li>用数组实现的顺序栈：<ul>
<li>构造函数初始化数组</li>
<li>入栈的时候，先判断数组空间是否足够，不够直接返回false，表明入栈失败，足够的话将item放到下标为count的位置，并且count加1</li>
<li>出栈的时候，先判断数组空间是否为空，为空直接返回空，不为空，则返回count-1位置的数组元素，并将count减1</li>
<li>位置为0的地方为栈底，位置为count的地方为栈顶。</li>
</ul>
</li>
<li>用链表实现的链式栈<ul>
<li>链表头部为栈顶，尾部为栈底可以实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何实现支持动态扩容的顺序栈？</p>
<ul>
<li>底层依赖一个支持动态扩容的数组就可以了。栈满的时候，申请一个更大的数组，将原来的数据搬移到新数组中。</li>
</ul>
</li>
<li><p>栈在表达式求值中的应用，举例说明34+13x9+44-12/3这个运算是如何处理的？</p>
<ul>
<li>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈，从左到右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，则和运算符栈的栈顶元素进行比较，如果比栈顶的运算符优先级高，就将当前运算符压入栈；否则从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</li>
<li>关键是，取当前运算符和栈顶比较，当前高的时候才入栈，低或者等于都直接计算</li>
</ul>
</li>
<li><p>栈在括号匹配中的应用</p>
<ul>
<li>用栈来保存为匹配的左括号，从左到右依次扫描字符串</li>
<li>当扫描到左括号的时候，直接压入栈中；当扫描到右括号的时候，从栈顶取出一个左括号，如果能匹配，则继续扫描剩下的字符串；如果不能匹配，则说明括号不合法。</li>
</ul>
</li>
<li><p>栈如何实现浏览器的前进、后退功能？</p>
<ul>
<li>用两个栈实现，首次浏览的时候压入栈A，点击后退的时候从A栈出栈，压入栈B，点击前进的时候从栈B出栈，压入栈A。</li>
</ul>
</li>
</ol>
<h4 id="第9讲-队列"><a href="#第9讲-队列" class="headerlink" title="第9讲 队列"></a>第9讲 队列</h4><ol>
<li><p>实现队列的两种方式？如何实现？</p>
<ul>
<li>数组实现的顺序队列<ul>
<li>构造函数申明数组大小，head指向队头下标，tail指向队尾下标</li>
<li>入队的时候判断队满，未满则队尾下标++</li>
<li>出队的时候判断队空，非空则队头下标++</li>
<li>数组不够用的时候可以通过数据搬移处理。可以在入队的时候判断队满，则数据搬移。</li>
</ul>
</li>
<li>链表实现的链式队列<ul>
<li>head指针指向链表的第一个结点，tail指针指向链表的最后一个结点。</li>
<li>链尾入队，链头出队</li>
</ul>
</li>
</ul>
</li>
<li><p>循环队列如何判断队空和队满？</p>
<ul>
<li>队空：head == tail</li>
<li>队满：(tail+1)%n == head</li>
<li>会浪费一个数组的存储空间</li>
</ul>
</li>
<li><p>线程池没有空闲线程时，新的任务请求线程资源的时候，线程池该如何处理？各种处理策略又是如何实现的？</p>
<ul>
<li>非阻塞的处理方式：直接拒绝任务请求</li>
<li>阻塞的处理方式：请求排队，等有空闲线程时，取出排队的请求继续处理。<ul>
<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能导致过多的请求排队等待，请求处理的响应时间过长。</li>
<li>基于数组的实现方式，可以实现一个有界队列，排队的请求超过队列大小的时候，接下来的请求都会被拒绝。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第11、12、13、14讲-排序"><a href="#第11、12、13、14讲-排序" class="headerlink" title="第11、12、13、14讲 排序"></a>第11、12、13、14讲 排序</h4><ol>
<li>冒泡排序如何实现？时间复杂度、空间复杂度、稳定性如何？<ul>
<li>实现<ul>
<li>对相邻的两个元素进行比较，看是否满足大小关系要求，不满足就让它们交换位置。</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(n),要排序的数组已经是有序的</li>
<li>最坏：O(n2),要排序的数组刚好是逆序的</li>
<li>平均：O(n2),可以根据逆序度来计算</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)，原地排序</li>
</ul>
</li>
<li>稳定性<ul>
<li>当相邻的两个元素大小相等的时候不交换，就不会改变顺序，就是稳定的算法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入排序如何实现？时间复杂度、空间复杂度、稳定性如何？<ul>
<li>实现思路<ul>
<li>将数组中的数据分为两个空间，已排序区间和未排序区间，取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(n)，要排序的数据已经是有序的，同时从尾到头去遍历已排序好的数组</li>
<li>最坏：O(n2),数组是倒序的</li>
<li>平均：O(n2)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
<li>稳定性<ul>
<li>值相同的元素，选择将后面出现的元素插入到前面出现元素的后面，就能保持稳定。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>选择排序如何实现？时间复杂度、空间复杂度、稳定性如何？</p>
<ul>
<li>实现<ul>
<li>也是分已排序区间和未排序区间，然后从未排序区间里找到最小的元素，将其放到已排序区间的末尾</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(n2)</li>
<li>最坏：O(n2)</li>
<li>平均：O(n2)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
<li>稳定性<ul>
<li>不稳定，交换的时候可能将后面的元素交换到前面去了。</li>
</ul>
</li>
</ul>
</li>
<li><p>冒泡排序和插入排序的实际复杂度都是O(n2)，为什么插入排序比冒泡排序更受欢迎？</p>
<ul>
<li>在内层循环里面，冒泡排序需要进行交换，有三个赋值的动作，而插入排序只有一次赋值，所以效率会更高一些。</li>
</ul>
</li>
<li><p>归并排序如何实现？时间复杂度、空间复杂度、稳定性如何？</p>
<ul>
<li>实现<ul>
<li>先从数组中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合在一起。</li>
<li>主要用到分治思想</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>任何情况下都是 ： O(nlogN)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
</ul>
</li>
<li>稳定性<ul>
<li>merge的时候，将前面的元素放在前面就能保证是稳定的算法</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推公式：</span></span><br><span class="line"><span class="comment">//merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//终止条件：</span></span><br><span class="line"><span class="comment">//p &gt;= r 不用再继续分解</span></span><br><span class="line"><span class="comment">// 归并排序算法, A 是数组，n 表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取 p 到 r 之间的中间位置 q</span></span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  <span class="comment">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span></span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>快速排序如何实现？时间复杂度、空间复杂度、稳定性如何？<ul>
<li>实现<ul>
<li>找到一个分区点，小的放左边，大的放右边，然后再去处理左边和右边</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(nLogN),分区均衡</li>
<li>最坏：O(n2),分区不均衡</li>
<li>平均：O(nlogN)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>可以实现原地的快速排序</li>
</ul>
</li>
<li>稳定性<ul>
<li>可以实现稳定</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推公式：</span></span><br><span class="line"><span class="comment">//quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//终止条件：</span></span><br><span class="line"><span class="comment">//p &gt;= r</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(result, <span class="number">0</span>, result.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = partition(array, start, end);</span><br><span class="line">        quickSort(array, start, mid - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = array[end];</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; flag) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[i];</span><br><span class="line">                array[i] = temp;</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[end];</span><br><span class="line">        array[end] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>O(n) 时间复杂度内求无序数组中的第 K 大元素?</p>
<ul>
<li>可以利用快排的原理，以最后的为分界点，如果右边的数组长度大于K，说明第K大元素就在后面，如果p+1 = k，说明A[p]就是要求解的元素</li>
</ul>
</li>
<li><p>如果有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的，你希望将这10个较小的日志文件，合并为1一个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB,有什么解决思路，能快速地将这10个日志文件合并吗？</p>
<ul>
<li>构建10条io流，每次选出时间戳最小的那条数据写入到新的文件中，一次类推。</li>
</ul>
</li>
<li><p>桶排序如何实现？时间、空间复杂度、稳定性如何？适合哪些场景？</p>
<ul>
<li>实现<ul>
<li>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。</li>
</ul>
</li>
<li>适用场景<ul>
<li>首先，要排序的数据需要很容易就能划分成m个痛，并且桶与桶之间有天然的大小顺序</li>
<li>其次，数据在各个桶之间的分布是比较均匀的，如果不均匀，会退化为快速排序算范</li>
<li>比较适合用在外部排序，就是数据存储在外部磁盘中，数据量比较大，内存优先，无法将数据全部加载到内存中。</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(n),分到m个桶里，每个桶有K = n/m个元素，桶内快速排序，复杂度为O(klogK) * m = O(nlog(n/m)) == O(n)</li>
</ul>
</li>
<li><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2></li>
<li>稳定性 <ul>
<li>桶内快排是稳定的，所以可以是稳定的。</li>
</ul>
</li>
</ul>
</li>
<li><p>有10GB的订单数据，希望按订单金额来排序，但是内存优先，只有几百MB,没办法一次性把10GB的数据都加载到内存中，这个时候应该怎么办？</p>
<ul>
<li>桶排序，先扫描一遍文件，看看订单金额的数据范围。然后根据订单金额分100个桶或更多，如果一个桶里的数据过多，还可以在桶内再进行桶的划分排序</li>
</ul>
</li>
<li><p>计数排序如何实现？时间、空间复杂度、稳定性如何？适用于哪些场景中？</p>
<ul>
<li>实现<ul>
<li>计数排序可以说是桶排序的一种特殊情况，要排序的n个数据，所处的范围并不大，每个桶内的数据值都是相同的，省掉了桶内排序的时间</li>
</ul>
</li>
<li>适用场景<ul>
<li>只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用基数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下转换为非负整数</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(n)</li>
</ul>
</li>
<li>空间复杂度</li>
<li>稳定性<ul>
<li>可以实现稳定。</li>
</ul>
</li>
</ul>
</li>
<li><p>基数排序如何实现？时间、空间复杂度、稳定性如何？适用于哪些场景中？</p>
<ul>
<li>实现</li>
<li>适用场景<ul>
<li>对要排序的数据是有要求的，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果a数据的高位比b数据大， 那么剩下的地位就不用比较了，初次之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则基数排序的时间复杂度就无法做到O(n)了。</li>
</ul>
</li>
</ul>
</li>
<li><p>假设我们现在需要对D,a,F,B,c,A,z这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为a,c,z,D,F,B,A，这个如何实现？如果字符串中存储的不仅有大小写字母，还有数字，要将小写字母放前面，大写字母放最后，数字翻中间，不用排序算法，有如何解决？</p>
<ul>
<li>只有大小写，前后两个指针，前指针找到大写字母，后指针找到小写字母，交换即可。</li>
<li>如果有大小写和数字的话，可以用桶排序了，也可以先小写和非小写，然后再大写和数字</li>
</ul>
</li>
<li><p>Java中的排序函数是用哪种排序算法实现的？</p>
<ul>
<li>Collections.sort()内部还是用的Arrays.sort()来实现的，</li>
<li>元素个数小于47用插入排序</li>
<li>47到286之间，用快速排序，优化的三值取中的优化版本</li>
<li>大于286使用归并排序(这里还有点存疑，TimSort等，看堆排序里怎么说。)</li>
</ul>
</li>
<li><p>为什么用快速排序而不是归并排序来做基本的排序函数？</p>
<ul>
<li>归并排序需要额外的内存空间，比如要排序100MB的数据，还需要额外再占用100MB的内存空间，而快速排序可以做到原地排序</li>
</ul>
</li>
<li><p>如何优化快速排序？</p>
<ul>
<li>选用合适的分区点<ul>
<li>三数取中法，首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。</li>
<li>随机法，</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第15、16讲-二分查找"><a href="#第15、16讲-二分查找" class="headerlink" title="第15、16讲 二分查找"></a>第15、16讲 二分查找</h4><ol>
<li><p>什么是二分查找？</p>
<ul>
<li>实现思路：<ul>
<li>针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟取件中的中间元素对比，将待查找的区间缩小为之前的一般，直到找到要查找的元素，或者区间被缩小为0</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(logN)</li>
</ul>
</li>
</ul>
</li>
<li><p>二分查找的递归和非递归实现</p>
<ul>
<li>代码见底部</li>
<li>非递归实现注意三点<ul>
<li>循环退出条件是low&lt;=hight，有等号</li>
<li>mid取值可以用位运算，防止溢出和优化性能</li>
<li>low和high要+1、-1，不然可能发生死循环</li>
</ul>
</li>
</ul>
</li>
<li><p>二分查找的局限性？</p>
<ul>
<li>二分查找依赖的是数组，不然无法做到O(1)的情况下取到数值</li>
<li>针对的是有序数据，无序的话，无法做到比较大小判断左右</li>
<li>数据量太大、太小都不适合二分查找，太小可以直接顺序遍历，太大的话，可能没有足够的连续空间来存储用来二分查找的数组。</li>
</ul>
</li>
<li><p>如何在1000万个整数中快速查找某个整数？</p>
<ul>
<li>先排序，再利用二分查找算法</li>
<li>不能用散列表或二叉树的原因是，这两者都需要额外的内存空间，而二分查找不需要。</li>
</ul>
</li>
<li><p>如何变成实现“求一个数的平方根”？要求精确到小数点后6位。</p>
<ul>
<li>先二分查找求整数，再求小数点后1位，以此类推。</li>
</ul>
</li>
<li><p>如果用链表存储，二分查找的时间复杂度是多少？为什么用数组而不是二分查找？</p>
<ul>
<li>O(n)，和顺序查找时间复杂度一致，但是比顺序查找还多了一些计算。</li>
</ul>
</li>
<li><p>二分查找的4种常见变形问题？</p>
<ol>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个大于等于给定值的元素</li>
</ol>
</li>
<li><p>如何快速定位出一个IP地址的归属地？</p>
<ul>
<li>现将IP地址转为32位的整型数并排序好，然后用二分查找。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形1：查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value))&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形2：查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形3：查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形4：查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch7</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第17讲-跳表-tips：了解即可"><a href="#第17讲-跳表-tips：了解即可" class="headerlink" title="第17讲 跳表(tips：了解即可)"></a>第17讲 跳表(tips：了解即可)</h4><ol>
<li><p>什么是跳表？</p>
<ul>
<li>链表上加多级索引的结构就是跳表</li>
<li>是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树。</li>
<li>Redis中的有序集合(Sorted Set)就是用跳表来实现。</li>
</ul>
</li>
<li><p>跳表中查询数据的时间/空间复杂度各是多少？</p>
<ul>
<li>时间复杂度为O(logN)，前提是建立了多级的索引</li>
<li>空间复杂度是O(n)</li>
</ul>
</li>
<li><p>跳表的插入、删除操作如何实现？时间复杂度是多少？</p>
<ul>
<li>插入操作，时间复杂度为O(logN)<ul>
<li>为了保证链表的有序性，插入操作需要先查找到插入的位置(O(logN))然后进行插入操作(O(1))</li>
</ul>
</li>
<li>删除操作，时间复杂度为O(logN)<ul>
<li>删除的时候也是先查找同时拿到前驱结点，然后直接删除。</li>
</ul>
</li>
</ul>
</li>
<li><p>跳表在插入删除等系列操作后可能会退化为单链表，这个时候如何处理？</p>
<ul>
<li>进行索引的动态更新<ul>
<li>通过随机函数实现。随机函数决定将这个结点插入到哪几级索引中，Rubicon随机函数沙僧城了值K，那么我们就讲这个结点添加到第一级到第K级这K级索引中。随机函数需要保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第18、19、20讲-散列表"><a href="#第18、19、20讲-散列表" class="headerlink" title="第18、19、20讲 散列表"></a>第18、19、20讲 散列表</h4><ol>
<li><p>什么是散列表(Hash Table)？</p>
<ul>
<li>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。</li>
<li>通过散列函数将元素的键值映射为下标，然后将数据存储在数组对应下标的位置。当我们按照键值查询元素的时候，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</li>
</ul>
</li>
<li><p>如何构造散列函数？</p>
<ul>
<li>散列函数计算得到的散列值是一个非负整数</li>
<li>如果key1=key2，那么hash(key1) == hash(key2)</li>
<li>如果key1 != key2,那么hash(key1) != hash(key2)</li>
</ul>
</li>
<li><p>解决散列冲突的两种方法？</p>
<ul>
<li>开放寻址法<ul>
<li>线性探测<ul>
<li>如果出现了散列冲突，就重新探测一个空闲位置，将其插入；删除操作的时候，只能标记为delete不然会出错。</li>
</ul>
</li>
<li>二次探测</li>
<li>双重散列</li>
</ul>
</li>
<li>链表法<ul>
<li>散列值相同的元素都放在相同槽位中对应的链表中。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何设计工业级的散列函数？</p>
<ul>
<li>设计不能太复杂。过于复杂会消耗过多的计算时间</li>
<li>生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突。</li>
</ul>
</li>
<li><p>如何避免低效的扩容？</p>
<ul>
<li>可以将扩容操作穿插在插入操作的过程中，分批完成。当有新数据要插入的时候，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程，经过多次插入操作之后，老的散列表中嘚瑟护甲就一点一点全部搬移到新散列表中了。</li>
</ul>
</li>
<li><p>如何选择冲突解决方法？</p>
<ul>
<li>Java中的LinkedHashMap就采用了链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突的。</li>
<li>开放寻址：<ul>
<li>优点：散列表中的数据都存储在数组中，可以有效地利用cpu缓存加快查询速度。同时序列化比较简单</li>
<li>缺点：删除数据的时候比较麻烦，比起链表法，冲突的代价更高</li>
<li>当数据量比较少、装载因子小的时候，适合用开放寻址法。</li>
</ul>
</li>
<li>链表法：<ul>
<li>优点：内存利用率高；对大装载因子的容忍度更高。</li>
<li>缺点：对CPU缓存不友好</li>
<li>适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</li>
</ul>
</li>
</ul>
</li>
<li><p>分析一下HashMap是如何实现的？</p>
<ul>
<li>初始大小<ul>
<li>默认为16，如果事先知道数据量，可以修改默认初始大小，可以减少动态扩容的次数，会提高HashMap的性能</li>
</ul>
</li>
<li>装载因子和动态扩容<ul>
<li>最大装载因子默认为0.75，每次扩容为原来的两倍</li>
</ul>
</li>
<li>散列冲突解决方法<ul>
<li>链表法解决冲突。在JDK1.8中，当链表长度太长(默认超过8)时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点提高HashMap的性鞥。</li>
</ul>
</li>
<li>散列函数<ul>
<li>就是返回对象的hash code</li>
</ul>
</li>
</ul>
</li>
<li><p>LinkedHashMap是如何实现的？</p>
<ul>
<li>通过双向链表和散列表两种数据结构结合实现的。</li>
</ul>
</li>
</ol>
<h4 id="第23、24讲-二叉树基础"><a href="#第23、24讲-二叉树基础" class="headerlink" title="第23、24讲 二叉树基础"></a>第23、24讲 二叉树基础</h4><ol>
<li><p>二叉树中，节点的高度、深度、层数，树的高度各是什么？</p>
<ul>
<li>节点的高度等于节点到叶子节点的最长路径(边数)</li>
<li>节点的深度等于根节点到这个节点所经历的边的个数</li>
<li>节点的层数等于节点的深度+1</li>
<li>数的高度等于根节点的高度</li>
</ul>
</li>
<li><p>如何表示(或存储)一棵二叉树？</p>
<ul>
<li>基于指针或者引用的二叉链表式存储法<ul>
<li>节点有三个字段，一个存储数据，一个存指向左子节点的指针，一个存指向右子节点的指针</li>
</ul>
</li>
<li>基于数组的顺序存储法<ul>
<li>根节点存储在下标为<code>i = 1</code>的位置，则左子节点存储在<code>2 * i = 2</code>的位置，右子节点存储在<code>2 * i + 1 = 3</code>的位置，以此类推。</li>
<li>适合完全二叉树存储</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的三种遍历方式？</p>
<ul>
<li>时间复杂度是O(n)，代码见底部</li>
</ul>
</li>
<li><p>给定一组数据，可以构建出多少种不同的二叉树？</p>
<ul>
<li>N的阶乘</li>
</ul>
</li>
<li><p>什么是二叉查找树？</p>
<ul>
<li>二叉查找树是为了实现快速查找而生的，二叉查找树要求，在树中的任意一个节点，其左子树中每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</li>
</ul>
</li>
<li><p>二叉查找树的查找、插入、删除操作流程？</p>
<ul>
<li>查找：<ul>
<li>先取根节点，如果它等于target，直接返回</li>
<li>如果target比根节点小，在左子树中递归查找</li>
<li>如果target比根节点大，在右子树中递归查找。</li>
</ul>
</li>
<li>插入：<ul>
<li>新插入的数据一般都是在叶子节点的，先查找，然后判断大小插入左子树还是右子树中</li>
</ul>
</li>
<li>删除：<ul>
<li>删除的结点没有子节点<ul>
<li>直接删除，拿到父节点指向该节点的指针置为null即可</li>
</ul>
</li>
<li>删除的阶段只有一个子节点<ul>
<li>将父节点指向该节点的指针指向该节点的子节点</li>
</ul>
</li>
<li>删除的结点有两个子节点 <ul>
<li>找到这个节点的右子树中的最小节点，把它替换到要删除的结点上，然后再删除这个最小节点。 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉查找树的中序遍历有什么特点？</p>
<ul>
<li>输出的是有序的数据序列，时间复杂度是O(n)，所以二叉查找树也称为二叉排序树</li>
</ul>
</li>
<li><p>散列表的插入、删除、查找操作的实际复杂度可以做到常量级的O(1),非常搞笑。而二叉查找树在比较平衡的情况下，插入、删除、查找操作实际复杂度才是O(logN)，相对散列表好像没有什么优势，为什么还要用二叉查找树呢？</p>
<ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，进行一遍中序遍历就可以了。可以在O(n)的时间复杂度内输出。</li>
<li>散列表扩容耗时很多，而且遇到散列冲突时，性能不稳定。而常用的平衡二叉树的性能非常稳定，时间复杂度稳定在O(logN)</li>
<li>尽管散列表的查找等操作的实际复杂度是常量级的，但是因为哈希冲突的存在，这个常量不一定比logN小，所以实际的查找时间不一定比O(logN)快，加上哈希函数的耗时，不一定比平衡二叉树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多，如散列函数的设计、冲突解决方法、扩容、缩容等。而平衡二叉查找树只需要考虑平衡性这一个问题。</li>
<li>为了避免过多的散列冲突，散列表装载因子不能太大，不然会浪费一定的存储空间。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第25、26讲-红黑树"><a href="#第25、26讲-红黑树" class="headerlink" title="第25、26讲 红黑树"></a>第25、26讲 红黑树</h4><ol>
<li><p>什么是平衡二叉树？什么是平衡二叉查找树？</p>
<ul>
<li>平衡二叉树要求，二叉树中任意一个节点的左右子树的高度相差不能大于1.</li>
<li>平衡二叉查找树则满足平衡二叉树和二叉查找树两个定义。</li>
</ul>
</li>
<li><p>什么是红黑树？有什么要求？</p>
<ul>
<li>红黑树中的节点，一类被标记为黑色，一类被标记为红色，除此之外：<ul>
<li>根节点是黑色的</li>
<li>每个叶子节点都是黑色的空节点(NIL)，也就是说叶子节点不存储数据(简化红黑树的代码实现而设置)</li>
<li>任何相邻的结点都不能同时为红色，也就是说红色节点是被黑色节点隔开的。</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。</li>
</ul>
</li>
<li>红黑树的高度近似logN，所以它是近似平衡的，插入、删除、查找操作的时间复杂度都是O(logN)</li>
<li>红黑树是一种性能非常稳定的二叉查找树，所以在工程中，凡是用到动态插入、删除、查找数据的场景，都可以用到它。 </li>
<li>自己实现困难，可以用跳表替换</li>
</ul>
</li>
<li><p>为什么说红黑树是近似平衡的？</p>
<ul>
<li>黑色节点取出来，是一个完全四叉树，所以只是多一倍的空间。</li>
</ul>
</li>
<li><p>动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，还有哪些？比较一下各自的优势、劣势、应用场景。</p>
<ul>
<li>散列表<ul>
<li>O(1),最常用，缺点是不能顺序遍历，及扩容缩容的性能损耗</li>
</ul>
</li>
<li>跳表<ul>
<li>O(logN)，能顺序遍历，缺点是空间复杂度O(n)，使用不在意内存空间的场景</li>
</ul>
</li>
<li>红黑树<ul>
<li>O(logN)，中序遍历即顺序遍历，稳定，缺点是难以实现，可以用跳表替换。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何自己实现一个红黑树？</p>
<ul>
<li>基本思想：遇到什么样的节点排布，我们就对应怎么去调整<ul>
<li>左旋</li>
<li>右旋</li>
</ul>
</li>
<li>插入操作的平衡调整：红黑树规定，插入的节点必须是红色的，而且二叉查找树中新插入的节点都是放在叶子节点上。<ul>
<li>如果插入节点的父节点是黑色的，不用调整，满足</li>
<li>如果插入的节点是根节点，直接改变颜色，变成黑色即可。</li>
<li>其他情况：需要做左右旋转和改变颜色，正在处理的节点为关注节点，关注节点会随着迭代而变化，最开始的关注节点是新插入的节点。<ul>
<li>case1 ：如果关注节点的叔叔节点是红色的<ul>
<li>将关注节点的父节点、叔叔节点都设置成黑色</li>
<li>将关注节点的祖父节点设置为红色</li>
<li>关注节点变化为祖父节点</li>
<li>调到case2或case3</li>
</ul>
</li>
<li>case2 ：如果关注节点的叔叔节点是黑色的，关注节点是其父节点的右子节点<ul>
<li>关注节点变化为父节点</li>
<li>围绕将新的关注节点左旋</li>
<li>调到case3</li>
</ul>
</li>
<li>case3 ： 如果关注节点的叔叔节点是黑色，关注节点是其父节点的左子节点<ul>
<li>围绕关注节点的祖父节点右旋</li>
<li>将新树中，关注节点的父节点和关注节点的兄弟节点颜色互换</li>
<li>调整结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>删除操作的平衡调整，分两步<ul>
<li>针对删除结点初步调整</li>
<li>针对关注节点进行二次调整</li>
<li>过。有时间有闲心再来背这个吧。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第28、29讲-堆和堆排序、堆的应用"><a href="#第28、29讲-堆和堆排序、堆的应用" class="headerlink" title="第28、29讲 堆和堆排序、堆的应用"></a>第28、29讲 堆和堆排序、堆的应用</h4><ol>
<li><p>堆是怎样的？有什么要求？</p>
<ul>
<li>堆是一个完全二叉树</li>
<li>堆中每个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。</li>
</ul>
</li>
<li><p>如何实现一个堆？</p>
<ul>
<li>往堆中插入一个元素<ul>
<li>从下往上堆化<ul>
<li>因为每次插入都是插入在堆的最后，每次比较关注节点和父节点，不满足大小关系就互换。</li>
</ul>
</li>
</ul>
</li>
<li>删除堆顶元素<ul>
<li>从上往下堆化。删除元素后，先将堆尾元素补充到删除元素位置，然后做从上往下堆化。</li>
</ul>
</li>
<li>往堆中插入、删除堆顶元素的时间复杂度都是O(logN)</li>
</ul>
</li>
<li><p>如何基于堆实现排序？</p>
<ul>
<li>时间复杂度为O(nlogN)的原地排序</li>
<li>建堆，时间复杂度是O(n)<ul>
<li>从后往前处理数组，每个数据都是从上往下堆化。叶子节点没有子节点，可以从后往前第一个父节点开始堆化。</li>
</ul>
</li>
<li>排序，时间复杂度是O(nlogN)<ul>
<li>数组的第一个元素是堆顶，是最小或者最大的元素，将它和n位置的元素互换，然后将前面n-1个元素堆化，继续将第一个和n-1位置的元素互换，一直重复。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么在实际开发中，快读排序要比堆排序性能好？</p>
<ul>
<li>堆排序数据访问的方式没有快速排序友好。堆排序数据是跳着访问的，对CPU缓存不友好</li>
<li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</li>
</ul>
</li>
<li><p>堆的应用场景？</p>
<ul>
<li>优先级队列</li>
<li>利用堆求Top K</li>
<li>利用堆求中位数</li>
</ul>
</li>
</ol>
<h4 id="第30、31讲-图的表示，及深度、广度优先搜索算法"><a href="#第30、31讲-图的表示，及深度、广度优先搜索算法" class="headerlink" title="第30、31讲 图的表示，及深度、广度优先搜索算法"></a>第30、31讲 图的表示，及深度、广度优先搜索算法</h4><ol>
<li><p>如何理解“图”？</p>
<ul>
<li>非线性表数据结构</li>
<li>图中的元素叫做顶点，图的一个顶点可以与任意其他顶点建立连接关系，这种建立的关系叫做边。跟顶点相连接的边的条数就是顶点的度。</li>
<li>有方向的图叫做有向图，没有方向的图叫做无向图</li>
<li>有向图中，有多少条表指向这个顶点成为入度；有多少条边是以这个顶点为七店指向其他顶点的，叫做顶点的出度。</li>
<li>每条边都有一个权重的，叫做带权图。</li>
</ul>
</li>
<li><p>如何在内存中存储图这种数据结构？</p>
<ul>
<li>邻接矩阵(二维数组)<ul>
<li>空间换时间</li>
<li>优点是：存储方式简单、直接，获取两个顶点的关系的时候非常高效；方便计算，可以将很多图的运算转换成矩阵之间的计算。</li>
<li>缺点是：可能比较浪费存储空间</li>
</ul>
</li>
<li>邻接表<ul>
<li>时间换空间</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先搜索BFS如何实现？</p>
<ul>
<li>先查找离起始顶点最近的，然后是次近的，一次往外搜索。</li>
<li>时间复杂度：O(V+E),V表示顶点的个数，E表示边的个数</li>
<li>空间复杂度：O(V),V表示顶点的个数</li>
</ul>
</li>
<li><p>深度优先搜索DFS如何实现？</p>
<ul>
<li>优先沿着一条路径一直走下去，没有路了再回来找其他的路径，回溯思想。</li>
<li>时间复杂度：O(E),E表示边的个数</li>
<li>空间复杂度：O(V),V表示顶点的个数</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印 s-&gt;t 的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第32、33、34讲-字符串匹配基础"><a href="#第32、33、34讲-字符串匹配基础" class="headerlink" title="第32、33、34讲 字符串匹配基础"></a>第32、33、34讲 字符串匹配基础</h4><ol>
<li><p>BF算法(Brute Force算法，暴力匹配算法，朴素匹配算法)</p>
<ul>
<li>在主串中，检查起始位置分别是0、1、2、3…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配。</li>
<li>最坏情况下的时间复杂度是O(n*m)</li>
<li>实际开发中是一个常用的字符串匹配算法：<ul>
<li>实际开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串的子串匹配的时候，当中图遇到不能匹配的字符的时候，就可以停止了，不需要把m个字符都比对一下。</li>
<li>算法思想简单，代码实现也简单。</li>
</ul>
</li>
</ul>
</li>
<li><p>RK算法(Rabin-Karp算法)</p>
<ul>
<li>借助哈希算法对BF算法进行改造：通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。</li>
<li>时间复杂度：O(n)，极端情况下，大量哈希冲突，退化为O(n*m)</li>
<li>哈希冲突存在，所以可以比较哈希值相等的时候，再对比一下子串和模式串本身就好了。</li>
</ul>
</li>
<li><p>BM算法(Boyer-Moore)算法</p>
<ul>
<li>非常高效的字符串匹配算法，性能是著名的KMP算法的3到4倍。在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。主要包括坏字符和好后缀规则。</li>
<li>坏字符规则<ul>
<li>从后往前匹配，找到第一个坏字符，然后在模式串中查找这个坏字符，si表示坏字符对应的模式传中字符下标，xi表示坏字符在模式串中存在，这个下标记为xi，如果不存在，则xi为-1，则模式串往后移动的位数就等于si-xi。注意xi以从后往前顺序获取，避免过度滑动。</li>
</ul>
</li>
<li>好后缀规则<ul>
<li>已经匹配好的后缀记作{u}，拿它在模式串中查找<ul>
<li>如果找到了另外一个匹配的子串{u*}，九江模式串滑动到对齐的位置</li>
<li>如果没有找到，就看好后缀的后缀子串是否存在跟模式串的前缀子串匹配的。有的话就滑动到对齐位置，没有的话，就直接滑动到好后缀的后面</li>
</ul>
</li>
</ul>
</li>
<li>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。 </li>
</ul>
</li>
<li><p>KMP算法(Knuth Morris Pratt算法) - todo</p>
<ul>
<li>坏字符</li>
<li>好前缀</li>
</ul>
</li>
</ol>
<h4 id="第37讲-贪心算法"><a href="#第37讲-贪心算法" class="headerlink" title="第37讲 贪心算法"></a>第37讲 贪心算法</h4><ol>
<li><p>贪心算法有哪些应用？</p>
<ul>
<li>霍夫曼编码(Huffman Coding)</li>
<li>Prim和Kruskal最小生成树算法</li>
<li>Dijkstra单源最短路径算法</li>
</ul>
</li>
<li><p>如何理解贪心算法？</p>
<ul>
<li>解题步骤<ul>
<li>看到这类问题，首先联想到贪心算法：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大</li>
<li>尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</li>
<li>举几个例子看下贪心算法产生的结果是否是最优的。</li>
</ul>
</li>
<li>用贪心算法解决问题的思路，并不总能给出最优解。如果前面的选择会影响后面的选择，这种情况下，贪心算法就不能给出最优解了。</li>
</ul>
</li>
<li><p>举例说明一下是如何运用贪心算法的？</p>
<ul>
<li>分糖果<ul>
<li>期望值是满足需求的人数越多，限制值是一定的糖果总量。可以优先满足需求低的。</li>
</ul>
</li>
<li>钱币找零<ul>
<li>限制值是纸币面值一定，期望值是张数越少。可以优先用面值大的，然后继续用面值小的。</li>
</ul>
</li>
<li>区间覆盖<ul>
<li>假设这n个区间中最左端点是lmin，最右是rmax。每次选择的时候，左端点跟前面的已经覆盖的区间不重合，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何用贪心算法实现霍夫曼编码？</p>
<ul>
<li>霍夫曼编码是一种有效的编码方法，用于数据压缩中，其压缩率通常在20%~90%之间。</li>
<li>不仅考察文本中有多少个不同字符，还会考察每个字符出现的频率，频率较多的字符用稍微短一些的编码；频率比较少的，用稍微长一些的编码。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码直接不会出现某个编码是另一个编码前缀的情况。</li>
</ul>
</li>
<li><p>在一个非负整数a中，我们希望从中移除k个数字，让剩下的数字最小，如何选择移除哪k个数字呢？</p>
<ul>
<li>由最高位开始，如果低位比它小，则移除它；否则右移一位判断。</li>
</ul>
</li>
<li><p>假设有n个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同改的，如何安排被服务的先后顺序，才能让这n个人总的等待时间最短？</p>
<ul>
<li>优先选择服务时间最短的</li>
</ul>
</li>
</ol>
<h4 id="第38讲-分治算法"><a href="#第38讲-分治算法" class="headerlink" title="第38讲 分治算法"></a>第38讲 分治算法</h4><ol>
<li>如何理解分治算法？<ul>
<li>分治算法能解决的问题，一般需要满足以下条件：<ul>
<li>原问题与分解成的小问题具有相同的模式</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性</li>
<li>具有分解终止条件，当问题足够小的时候，可以直接求解</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果。</li>
</ul>
</li>
<li>分治算法每层递归都会涉及这样三个操作：<ul>
<li>分解：将原问题分解成一系列子问题</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解</li>
<li>合并：将子问题的结果合并成原问题</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第39讲-回溯算法"><a href="#第39讲-回溯算法" class="headerlink" title="第39讲 回溯算法"></a>第39讲 回溯算法</h4><ol>
<li>如何理解回溯算法？<ul>
<li>类似枚举搜索：枚举所有的解，找到满足期望的解</li>
</ul>
</li>
<li>回溯算法的经典应用：八皇后问题<ul>
<li>依次将8个棋子放到第一行、第二行、第三行。。。第巴行，放置的过程中，不停地检查当前的方法是否满足要求。如果满足，则跳到下一行继续放置；如果不满足，就换一种方法继续尝试。</li>
</ul>
</li>
<li>回溯算法的经典应用：0-1书包问题<ul>
<li>将物品依次排列，整个问题就分解成了n个阶段，每个阶段对一个一个物品怎么选择：装进去或者不装进去，然后再递归地处理剩下的物品。</li>
</ul>
</li>
<li>回溯算法的经典应用：正则表达式<ul>
<li>依次考察正则表达式中的每个字符，当是非通配符的时候，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 八皇后问题</span></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];<span class="comment">// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8 个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8 行棋子都放好了，已经没法再往下递归了，所以就 return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有 8 中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第 row 行的棋子放到了 column 列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">// 判断 row 行 column 列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第 i 行的 column 列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第 i 行 leftup 列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第 i 行 rightup 列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">"* "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-1背包问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">// 存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w 背包重量；items 表示每个物品的重量；n 表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w 表示装满了 ;i==n 表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) &#123; <span class="comment">// * 匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) &#123; <span class="comment">// ? 匹配 0 个或者 1 个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第40讲-动态规划"><a href="#第40讲-动态规划" class="headerlink" title="第40讲 动态规划"></a>第40讲 动态规划</h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/21/GeekBang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/" data-id="ck8e3fmti00ie27qyckcdhimw" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-android-view-draw" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/09/04/android-view-draw/" class="article-date">
  <time datetime="2018-09-04T06:56:33.000Z" itemprop="datePublished">2018-09-04</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/Android/">Android</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/09/04/android-view-draw/">Android View绘制流程</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>View的绘制流程主要包括三个过程：measure过程计算View的宽高，layout过程计算View的四个顶点的左边和实际的View的宽高，draw过程绘制View，只有draw方法完成以后，view的内容才会呈现在屏幕上。</p>
        
          <p class="article-more-link">
            <a href="/mLixin.github.io/2018/09/04/android-view-draw/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/09/04/android-view-draw/" data-id="ck8e3fmn0000p27qy0ucg9t42" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/Android/" rel="tag">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/TODO/" rel="tag">TODO</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/View/" rel="tag">View</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-book-Java并发编程的艺术" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/08/27/book-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/" class="article-date">
  <time datetime="2018-08-27T09:06:36.000Z" itemprop="datePublished">2018-08-27</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/08/27/book-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/">Java并发编程的艺术 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>人有多大胆，地有多大产</p>
<h4 id="第一章-并发编程的挑战"><a href="#第一章-并发编程的挑战" class="headerlink" title="第一章 并发编程的挑战"></a>第一章 并发编程的挑战</h4><ol>
<li><p>如何减少上下文切换？</p>
<ul>
<li>无锁并发编程<ul>
<li>多线程竞争锁的时候会引起上下文切换，所以多线程处理数据的时候，可以用一些办法来避免使用锁，如将数据的ID按照Hash算法取模分段，不同的线程处理不同段的数据。</li>
</ul>
</li>
<li>CAS算法<ul>
<li>Java的Atomic包使用CAS算法来更新数据，而不需要加锁</li>
</ul>
</li>
<li>使用最少线程<ul>
<li>避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态</li>
</ul>
</li>
<li>使用协程<ul>
<li>在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换</li>
</ul>
</li>
</ul>
</li>
<li><p>如何避免死锁？</p>
<ul>
<li>避免一个线程同时获取多个锁</li>
<li>避免一个线程在锁内同时占用多个资源，尽量保证每个锁只占用一个资源</li>
<li>尝试使用定时锁，使用lock.tryLock(timeout)来替代使用内部锁机制</li>
<li>对于数据库锁，加锁和解锁必须在一个数据库连接里，否则会出现解锁失败的情况。</li>
</ul>
</li>
</ol>
<h4 id="第二章-Java并发机制的底层实现原理"><a href="#第二章-Java并发机制的底层实现原理" class="headerlink" title="第二章 Java并发机制的底层实现原理"></a>第二章 Java并发机制的底层实现原理</h4><ol>
<li><p>Java允许线程访问共享变量。如果一个字段被声明成volatile，Java线程内存模型确保所有线程看到这个变量的值是一致的。</p>
</li>
<li><p>相关概念？</p>
<ul>
<li>内存屏障<ul>
<li>一组处理器指令，用于实现对内存操作的顺序限制</li>
</ul>
</li>
<li>缓冲行<ul>
<li>缓存中可以分配的最小存储单位。处理器填写缓存线时会加载整个缓存线，需要使用多个主内存读周期</li>
</ul>
</li>
<li>原子操作<ul>
<li>不可中断的一个或一系列操作</li>
</ul>
</li>
<li>缓存行填充<ul>
<li>当处理器识别到从内存中读取操作数是可缓存的，处理器读取整个缓存行到适当的缓存</li>
</ul>
</li>
<li>缓存命中<ul>
<li>如果进行高速缓存行填充操作的内存位置仍然是下次处理器访问的地址时，处理器从缓存中读取操作数，而不是从内存读取</li>
</ul>
</li>
<li>写命中<ul>
<li>当处理器将操作数写会到一个内存缓存的区域时，它首先会检查这个缓存的内存地址是否在缓存行中，如果存在一个有效的缓存行，则处理器将这个操作数写会缓存，而不是写回到内存，这个操作被称作写命中。</li>
</ul>
</li>
<li>写缺失<ul>
<li>一个有效的缓存行被写入到不存在的内存区域。</li>
</ul>
</li>
<li>CAS(比较并交换)<ul>
<li>CAS操作需要输入两个数值，一个旧值和一个新值，在操作期间先比较旧值有没有发生变化，如果没有发生变化，才交换成新值，发生了变化则不交换</li>
</ul>
</li>
<li>CPU流水线(CPU pipeline)<ul>
<li>流水线的工作方式就像工业生产上的装配流水线，在CPU中由5<del>6个不同功能的电路单元组成一条指令处理流水线，然后将一条指令分成5</del>6步后再由这些电路单元分别执行，这样就能实现在一个CPU时钟周期完成一条指令，因此提高CPU的运行速度。</li>
</ul>
</li>
<li>内存顺序冲突 <ul>
<li>一般是由假共享引起的，假共享是指多个CPU同时修改同一个缓存行的不同部分而引起其中一个CPU的操作无效，当出现这个内存顺序冲突时，CPU必须清空流水线。</li>
</ul>
</li>
</ul>
</li>
<li><p>volatile两条实现原则？</p>
<ul>
<li>Lock前缀指令会引起处理器缓存会写到内存</li>
<li>一个处理器的缓存会写到内存会导致其他处理器的缓存无效</li>
</ul>
</li>
<li><p>synchronized锁的对象都是哪些？</p>
<ul>
<li>普通同步方法，锁是当前实例对象</li>
<li>静态同步方法，锁是当前类的Class对象</li>
<li>同步方法块，锁是synchronized括号里配置的对象。</li>
</ul>
</li>
<li><p>synchronized在JVM里的实现原理？</p>
<ul>
<li>JVM基于进入和退出Monitor对象来实现方法同步和代码块同步，但两者的实现细节不一样。代码块同步是使用monitorenter和monitorexit指令实现的，而方法同步是使用另外一种方式实现的，规范并未说明，也可以用上面两种指令实现。</li>
<li>monitorenter指令是在编译后插入到同步代码块的开始位置，而monitorexit是插入到方法结束处和异常出，JVM要保证每个monitorenter必须有对应的monitorexit与之配对。任何对象都有一个moitor与之关联，当且一个monitor被持有后，它将处于锁定状态。当线程执行到monitorenter指令的时候，会尝试获取对象多对应的omnotor的所有权，就是尝试获取对象的锁。</li>
</ul>
</li>
<li><p>Java对象头都存储哪些信息？</p>
<ul>
<li>如果对象是数组类型，则用3个字宽存储对象头</li>
<li>如果对象是非数组类型，则用2个字宽存储对象头</li>
<li>内容：<ul>
<li>Mark Word：存储对象的hashCode或锁信息<ul>
<li>25bit：对象的hashCode或锁信息</li>
<li>4bit：对象分代年龄</li>
<li>1bit：是否是偏向锁</li>
<li>2bit：锁标志位<ul>
<li>00：轻量级锁</li>
<li>10：重量级锁</li>
<li>11：GC标记</li>
<li>01：偏向锁</li>
</ul>
</li>
</ul>
</li>
<li>Class Metadata Address：存储到对象类型数据的指针</li>
<li>Array length：数组的长度</li>
</ul>
</li>
</ul>
</li>
<li><p>锁的四个状态和优先级？为什么锁只能设计不能降级？</p>
<ul>
<li>状态<ul>
<li>无锁</li>
<li>偏向锁</li>
<li>轻量级锁</li>
<li>重量级锁</li>
</ul>
</li>
<li>原因：提高获得锁和释放锁的效率</li>
</ul>
</li>
<li><p>偏向锁是什么？为什么会出现？</p>
<ul>
<li>大多数情况下，锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了降低线程获得锁的代价引入偏向锁。</li>
<li>当一个线程访问同步款并获取锁的时候，会在对象头和栈帧中的锁记录中存储锁偏向的线程ID，以后该线程在进入和退出同步块的时候，不需要进行CAS操作来加锁和解锁，只需要简单的测试对象头里面的Mark Word里面是否存储了指向当前线程的偏向锁。<ul>
<li>如果成功，表示线程已经获取了锁</li>
<li>如果失败，再测试一下Mark Word中偏向锁的标识是否设置为1(表示当前为偏向锁)，<ul>
<li>如果没有设置，则使用CAS竞争锁</li>
<li>如果设置了，则尝试使用CAS将对象头的偏向锁指向当前线程。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>偏向锁如何撤销？</p>
<ul>
<li>偏向锁在其他线程尝试竞争偏向锁的时候，持有偏向锁的线程才会释放<ul>
<li>等待全局安全点(没有正在执行的字节码)</li>
<li>暂停拥有偏向锁的线程，检查持有偏向锁的线程是否活着<ul>
<li>不处于活动状态，则将对象头设置为无锁状态</li>
<li>仍然活着，拥有偏向锁的栈会被执行，遍历偏向对象的锁记录和对象头的Mark Word要么重新偏向其他线程，要么恢复到无锁、或标记对象不适合作为偏向锁</li>
</ul>
</li>
<li>唤醒暂停的线程</li>
</ul>
</li>
</ul>
</li>
<li><p>轻量级锁如何加锁和解锁？</p>
<ul>
<li>加锁<ul>
<li>线程在执行同步块之前，JVM会先在当前线程的栈帧中创建用于存储锁记录的空间，并将对象头中的Mark Word复制到锁记录中(Displaced Mark WOrd)，然后线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针。如果成功，则获得锁；如果失败，表示其他线程竞争锁，当前线程边尝试使用自旋来获取锁</li>
</ul>
</li>
<li>解锁<ul>
<li>使用原子的CAS操作将Displaced Mark Word替换回到对象头，如果成功，则表示没有竞争发生。如果失败，表示当前锁存在竞争，锁就会膨胀成重量级锁。 </li>
</ul>
</li>
</ul>
</li>
<li><p>三种锁的优缺点等对比</p>
<ul>
<li>偏向锁<ul>
<li>加锁和解锁不需要额外的消耗，和执行非同步方法相比仅存在纳秒级的差距</li>
<li>如果线程间存在锁竞争，会带来额外的锁撤销的消耗</li>
<li>适用于只有一个线程访问同步块场景</li>
</ul>
</li>
<li>轻量级锁<ul>
<li>竞争的线程不会阻塞，提高了程序的响应速度</li>
<li>如果始终得不到锁竞争的线程，使用自旋会消耗CPU</li>
<li>追求响应时间，同步块执行速度非常快</li>
</ul>
</li>
<li>重量级锁<ul>
<li>线程竞争不适用自旋，不会消耗CPU</li>
<li>线程阻塞，响应速度缓慢</li>
<li>追求吞吐量，同步款执行速度较长。</li>
</ul>
</li>
</ul>
</li>
<li><p>处理器如何实现原子操作？</p>
<ul>
<li>使用总线锁保证原子性<ul>
<li>使用处理器提供的一个LOCK#信号，当一个处理器在总线上输出次限号的时候，其他处理器的请求将被阻塞住，那么该处理器可以独占共享内存。</li>
</ul>
</li>
<li>使用缓存锁保证原子性<ul>
<li>同一时刻，只需要保证对某个内存地址的操作是原子性的，但是总线锁定把CPU和内存之间的通信锁住了， 其他处理器不能操作其他内存地址的数据，所以总线锁的开销比较大</li>
<li>频繁使用的内存会缓存在处理器的L1、L2和L3高速缓存里，那么原子操作就可以直接在处理器内部缓存中进行，并不需要声明总线锁。</li>
<li>两种情况下处理器不会使用缓存锁定<ul>
<li>当操作的数据不能被缓存在处理器内部，或操作的数据跨多个缓存行时，则处理器会调用总线锁定</li>
<li>有些处理器不支持缓存锁定，</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Java如何实现原子操作？</p>
<ul>
<li>使用循环CAS实现原子操作<ul>
<li>JVM中的CAS操作正是利用了处理器提供的CMPXCHG指令实现的。自旋CAS实现的基本思路就是循环进行CAS操作直到成功为止。</li>
<li>CAS实现原子操作的三大问题：<ul>
<li><code>ABA问题</code>：A变成B又变成A，实际发生了变化，Compare确实没有发生变化。解决方案是在变量前面追加版本号</li>
<li><code>循环时间长开销大</code>：自旋CAS如果长时间不成功，会给CPU带来非常大的执行开销。解决方案是JVM支持处理器提供的pause指令(延迟流水线执行指令；避免在退出循环的时候因内存顺序冲突而引起CPU流水线被清空)</li>
<li><code>只能保证一个共享变量的原子操作</code>：多个共享变量时，CAS无法保证操作的原子性，这个时候可以用锁，也可以将多个共享变量合并成一个共享变量来操作，1.5后提供了AtomicReference类来保证引用对象之间的原子性，可以把多个变量放在一个对象里来进行CAS操作。</li>
</ul>
</li>
</ul>
</li>
<li>使用锁机制实现原子操作<ul>
<li>锁机制保证了只有获得锁的线程才能够操作锁定的内存区域。</li>
<li>除了偏向锁，JVM实现锁的方式都用了循环CAS,即当一个线程想进入同步快的时候，使用循环CAS的方式来获取锁，当它退出同步块的时候使用循环CAS释放锁。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第三章-Java内存模型"><a href="#第三章-Java内存模型" class="headerlink" title="第三章 Java内存模型"></a>第三章 Java内存模型</h4><ol>
<li><p>JMM是什么？有什么作用？</p>
<ul>
<li>Java线程之间的通信由JMM控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。</li>
<li>JMM通过控制主内存与每个线程的本地内存之间的交互，来为Java程序员提供内存可见性保证。</li>
</ul>
</li>
<li><p>什么是重排序？有哪几种重排序方式？重排序会导致什么问题？</p>
<ul>
<li>重排序是指编译器和处理器为了优化程序性能而对指令序列进行重新排序的一种手段</li>
<li>三种重排序：<ul>
<li>编译器优化的重排序：不改变单线程程序语义的前提下，可以重新安排语句的执行顺序</li>
<li>指令级并行的重排序：现代处理器采用ILP(指令级并行技术)来将多条指令重叠执行。</li>
<li>内存系统的重排序：由于处理器使用缓存和读写缓冲区，使得加载和存储操作看上去可能是在乱序执行。</li>
</ul>
</li>
<li>重排可能导致多线程程序出现内存可见性问题。</li>
</ul>
</li>
<li><p>重排序会带来什么问题？Java是如何解决的？有哪些内存屏障类型？</p>
<ul>
<li>为了保证内存可见性，Java编译器在生成指令序列的适当位置会插入内存屏障指令来禁止特定类型的处理器重排序<ul>
<li>LoadLoad Barriers：确保Load1数据的装载先于Load2及所有后续装载指令的装载</li>
<li>StoreStore Barriers：确保Store数据对其他处理器可见(刷新到内存)，先于Store2及所有后续存储指令的存储</li>
<li>LoadStore Barriers：确保Load1数据装载闲鱼Store2及所有后续的存储指令刷新到内存</li>
<li>StoreLoad Barriers：确保Store1数据对其他处理器变得可见，先于Load2及所有后续装载指令的装载。(全能型屏障，同时具有其他3个屏障的效果。)</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是数据依赖？有哪些类型？</p>
<ul>
<li>如果两个操作访问同一个变量，且这两个操作中有一个为写操作，此时这两个操作之间就存在数据依赖性</li>
<li>三种类型:<ul>
<li>写后读</li>
<li>写后写</li>
<li>读后写</li>
</ul>
</li>
</ul>
</li>
<li><p>重排序需要遵守哪些规则？</p>
<ul>
<li>数据依赖性：编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。(针对单个处理器和单个线程，不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑)</li>
<li>as-if-serial：不管怎么重排序，程序的执行结果不能被改变。(编译器、runtime和处理器都必须遵守as-if-serial语义)<ul>
<li>as-if-serial使单线程程序员无需担心重排序会干扰他们，也无须担心内存可见性问题。</li>
</ul>
</li>
</ul>
</li>
<li><p>顺序一致性内存模型的两大特性？</p>
<ul>
<li>一个县城中的所有操作必须按照程序的顺序来执行</li>
<li>所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。</li>
</ul>
</li>
<li><p>如何理解volatile？</p>
<ul>
<li>理解volatile特性的一个方法是吧volatile变量的单个读/写，看成是使用同一个锁对这些单个读/写做了同步。</li>
<li>volatile具有下列特性：<ul>
<li>可见性：对一个volatile变量的毒，总是能看到任意线程对这个volatile变量最后的写入</li>
<li>原子性：对任意单个volatile变量的读/写具有原子性，但类似于volatile++这种符合操作不具有原子性。</li>
</ul>
</li>
<li>从内存语义的角度来看，volatile的写-读与锁的释放-获取有相同的内存效果。</li>
<li>当写一个volatile变量的时候，JMM会把改线程对应的本地内存中的共享变量刷新到主内存中。</li>
<li>当读一个volatile变量的时候，JMM会把线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。</li>
<li>综合来看，在读线程B读一个volatile变量后，写线程A在写这个volatile变量之前所有可见的共享变量的值都会立即变得对B可见，因为volatile的关系写入内存的时候，之前所有的共享变量都会刷新到主内存中，而不仅仅是volatile修饰的变量。</li>
</ul>
</li>
<li><p>volatile写和读的内存语义？</p>
<ul>
<li>线程A写一个volatile变量，实际上是线程A向接下来要读这个volatile变量的某个线程发出了(其对共享变量所做修改)消息</li>
<li>线程B读一个volatile变量，实质上是线程B接收了之前某个线程发出的消息</li>
<li>线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息</li>
</ul>
</li>
<li><p>基于保守策略的JMM内存屏障插入策略？</p>
<ul>
<li>在每个volatile写操作的前面插入一个StoreStore屏障</li>
<li>在每个volatile写操作的后面插入一个StoreLoad屏障</li>
<li>在每个volatile读操作后面插入一个LoadLoad屏障</li>
<li>在每个volatile读操作的后面插入一个LoadStore屏障</li>
</ul>
</li>
<li><p>当线程释放锁的时候，JMM会把该线程对应的本地内存中的共享变量刷新到主内存中。当线程获取锁时，JMM会把线程对应的本地内存置为无效从而使得被监视器保护的临界区代码必须从内存中读取共享变量。</p>
</li>
<li><p>监视器锁规则：对一个锁的解锁happens-before随后对这个锁的加锁。锁释放与volatile写有相同的内存语义，锁获取与volatile读有相同的内存语义</p>
</li>
<li><p>锁释放和锁获取的内存语义？</p>
<ul>
<li>线程A释放一个锁，实际上是线程A向接下来要获取这个锁的某个线程发出了(线程A对共享变量所做修改)消息</li>
<li>线程B获取一个锁，实质是上线程B接收了之前某个线程发出的(在释放这个锁之前对共享变量所做修改的)消息</li>
<li>线程A释放锁，随后线程B获取这个锁，实质上是线程A通过住内存向线程B发送消息。</li>
</ul>
</li>
<li><p>ReentrantLock分为公平锁和非公平锁？</p>
<ul>
<li>公平锁<ul>
<li>释放锁的最后写volatile变量state，获取锁的时候首先读这个volatile变量。根据volatile的Happens-Before规则，释放锁的线程在写volatile变量之前可见的共享变量，在获取锁的线程读取同一个volatile变量后将立即变得对获取锁的线程可见。</li>
</ul>
</li>
<li>非公平锁<ul>
<li>释放锁和公平锁一样，获取锁的时候，首先会用CAS更新volatile变量，这个让从中同时具有volatile读和volatile写的内存语义。</li>
</ul>
</li>
</ul>
</li>
<li><p>4中Java线程之间的通信方式？</p>
<ul>
<li>A线程写volatile变量，随后B线程读这个volatile变量</li>
<li>A线程写volatile变量，随后B线程用CAS更新这个volatile变量</li>
<li>A线程用CAS更新一个volatile变量，随后B线程用CAS更新这个volatile变量</li>
<li>A线程用CAS更新这个volatile变量，随后B线程读这个volatile变量。</li>
</ul>
</li>
<li><p>final域，编译器和处理器要遵守的两个重排序规则？</p>
<ul>
<li>在构造函数内对一个final域的写入，与随后把这个被构造对象的引用赋值给一个引用变量，这两个操作之间不能重排序<ul>
<li>JMM禁止编译器把final域的写重排序到构造函数之外</li>
<li>编译器会在final域的写之后，构造函数return之前，插入一个StoreStore屏障。这个屏障禁止处理器把final域的写重排序到构造函数之外。</li>
</ul>
</li>
<li>初次读一个包含final域的对象的引用，与随后初次读这个final域，这两个操作之间不能重排序。</li>
</ul>
</li>
<li><p>happens-before的定义</p>
<ul>
<li>如果一个操作happens-before另一个操作，那么第一个操作的执行结果对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前；</li>
<li>两个操作之间存在happens-before关系，并不意味着Java平台的具体实现必须按照happens-before关系指定的顺序执行。如果重排序之后的执行结果，与按happens-before关系来执行的结果一直，那么这种重排序并不非法。</li>
</ul>
</li>
<li><p>happens-before和as-if-serial比较</p>
<ul>
<li>两者本质上是一样的</li>
<li>as-if-serial语义保证单线程内程序的执行结果不被改变，happens-before关系保证正确同步的多线程程序的执行结果不被改变</li>
<li>as-if-serial语义给单线程程序员一个幻境：程序是按程序的顺序执行的，happens-before关系给编写多线程程序的程序员一个幻境：正确同步的多线程程序是按happens-before指定的顺序来执行的。</li>
</ul>
</li>
<li><p>happens-before的六个规则：</p>
<ol>
<li>程序顺序规则<ul>
<li>一个线程中的而每个操作，happens-before于该线程中的任意后续操作</li>
</ul>
</li>
<li>监视器锁规则<ul>
<li>对一个锁的解锁，happens-before于随后对这个锁的加锁</li>
</ul>
</li>
<li>volatile变量规则<ul>
<li>对一个volatile域的写，happens-before于任意后续对这个volatile域的读</li>
</ul>
</li>
<li>传递性<ul>
<li>如果A happens-before B，且B happens-before C，则A happens-before C</li>
</ul>
</li>
<li>start()规则<ul>
<li>如果线程A执行操作ThreadB.start()，那么A线程的Thread.start()操作happens-before于线程B中的任意操作</li>
</ul>
</li>
<li>join()规则<ul>
<li>如果线程A执行操作ThreadB.join()并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回</li>
</ul>
</li>
</ol>
</li>
<li><p>为什么双重校验的单例模式不是线程安全的？如何优化？</p>
<ul>
<li>对象的创建分为<code>分配对象</code>,<code>初始化对象</code>,<code>设置instance指向刚刚分配的内存地址</code>，但是重排序的存在，会导致2和3重排序，就会出问题。</li>
<li>优化方案：<ul>
<li>volatile：当对象的引用用volatile修饰后，2和3直接的重排序在多线程环境中将会被禁止</li>
<li>类初始化：JVM在类的初始化阶段(在Class被加载后，且被线程使用之前)，会执行类的初始化。在执行类的初始化期间，JVM会去获取一个锁，这个锁可以同步多个线程对同一个类的初始化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第四章-Java并发编程基础"><a href="#第四章-Java并发编程基础" class="headerlink" title="第四章 Java并发编程基础"></a>第四章 Java并发编程基础</h4><ol>
<li><p>什么是线程？</p>
<ul>
<li>操作系统调度的最小单位是线程，也叫轻量级进程。在一个进程里可以创建多个线程，这些线程拥有各自的计数器、堆栈和局部变量等属性，并且能够访问共享的内存变量。</li>
</ul>
</li>
<li><p>为什么要使用多线程？</p>
<ul>
<li>更多的处理器核心</li>
<li>更快的响应时间</li>
<li>更好的编程模型</li>
</ul>
</li>
<li><p>线程的优先级</p>
<ul>
<li>线程创建的时候通过setPriority(int)方法来修改优先级，默认是5。优先级高的线程分配时间片的数量要多于优先级低的线程。</li>
<li>有些操作系统会忽略Java优先级，所以不能作为程序正确性的依赖。</li>
</ul>
</li>
<li><p>线程的状态</p>
<ul>
<li><code>NEW</code>：初始状态，线程被构建，还没有调用start()方法</li>
<li><code>RUNNABLE</code>：运行状态，Java线程将操作系统里的就绪状态和运行状态统称作运行中</li>
<li><code>BLOCKED</code>：阻塞状态，表示线程阻塞于锁</li>
<li><code>WAITING</code>：等待状态，表示线程进入等待状态，进入该状态，表示当前线程需要等待其他线程做出一些特定动作(通知或中断)</li>
<li><code>TIME_WAITING</code>：超时等待状态，和waiting不同，它是可以在指定的时间自行返回的</li>
<li><code>TERMINATED</code>：终止状态，表示当前线程已经执行完毕</li>
</ul>
</li>
<li><p>线程的状态如何转换？</p>
<ul>
<li>start()方法开始运行。</li>
<li>当线程执行wait()方法后，线程进入等待状态；<ul>
<li>进入等待状态的线程需要依靠其他线程的通知才能够回到运行状态，而超时等待状态相当于在等待状态的基础上增加了超时限制，超时时间到达的时候会返回到运行状态。</li>
</ul>
</li>
<li>当线程调用同步方法时，在没有获取到锁的情况下会进入到阻塞状态。</li>
<li>线程在执行Runnable的run()方法之后将会进入到终止状态。</li>
</ul>
</li>
<li><p>什么是Daemon线程？</p>
<ul>
<li>Daemon线程是一种支持型线程，主要被用作程序中后台调度以及支持性工作。当一个Java虚拟机不存在非Daemon线程的时候，Java虚拟机将会退出。</li>
</ul>
</li>
<li><p>线程如何构造？</p>
<ul>
<li>构造一个线程对象，线程对象在构造的时候需要提供线程所需要的属性，如线程所属的线程组、线程优先级、是否是Daemon线程等信息；</li>
<li>Java的Thread对象是由其parent线程来进行空间分配的，而child线程继承了parent是否为Daemon线程、优先级和加载资源的contextClassLoader以及可继承的ThreadLocal，同时还会分配一个唯一的ID来标识这个child线程。</li>
</ul>
</li>
<li><p>线程如何启动？</p>
<ul>
<li>start()方法即可启动线程，含义是：当前线程(parent线程)同步告知Java虚拟机，只要线程规划区空闲，应立即启动调用start()方法的线程。</li>
</ul>
</li>
<li><p>如何理解线程的中断？</p>
<ul>
<li>线程的一个标识位属性，标识一个运行中的线程是否被其他线程进行了中断操作。线程通过检查自身是否被中断来进行响应，通过方法isInterrupted()来进行判断是否被中断，也可以调用静态方法Thread.interrupted()对当前线程的中断标识位进行复位。如果该线程已经处于终结状态，及时该线程被中断过，在调用该线程对象的isInterrupt()时依旧会返回false。(许多声明抛出InterruptedException的方法在抛出InterruptedException之前，Java虚拟机会先将该线程的中断标志位清除，然后抛出InterruptedException，此时调用isInterrupted()将会返回false)</li>
</ul>
</li>
<li><p>线程的暂停、恢复和停止操作？为什么不建议使用了？</p>
<ul>
<li>suspend()</li>
<li>resume()</li>
<li>stop()</li>
<li>这些方法在调用后，比如suspend方法，在调用后，不会释放已经占有的资源，而是占有资源进入睡眠状态，容易引发死锁问题；同理stop()方法在终结一个线程时不会保证线程的资源正常释放，通常是没有给予线程完成资源释放工作的机会，因此会导致程序可能工作在不确定状态下。</li>
<li>可以用后面等待、通知机制来替代</li>
</ul>
</li>
<li><p>如何安全的终止线程？</p>
<ul>
<li>通过中断操作和cancel()方法均可使Thread得以终止。这种通过标识位或者中断操作的方式能够使线程在终止时有机会去清理资源，实现更安全和优雅。</li>
</ul>
</li>
<li><p>volatile和synchronized关键字</p>
<ul>
<li>volatile用来修饰字段(成员变量)，就是告知程序，任何对该变量的访问均需要从共享内存中获取，而对它的改变必须同步刷新回共享内存，它能保证所有线程对变量访问的可见性。但是过多的使用volatile是不必要的，会降低程序执行的效率</li>
<li>synchronized可以修饰方法或者以同步块的形式来进行使用，主要确保多个线程在同一个时刻，只能有一个线程处于方法或者同步块中，保证了线程对变量访问的可见性和排他性。<ul>
<li>解析class文件可发现，同步块的实现使用了monitorenter和monitorexit指令，而同步方法则是依靠方法修饰符上的ACC_SYNCHRONIZED来完成。本质是对一个对象的monitor进行获取，这个获取的过程是排他的，同一个时刻只能有一个线程获取到由synchronized所保护对象的监视器</li>
<li>任意对象都拥有自己的监视器，当这个对象由同步块或同步方法调用时，执行方法的线程必须先获取到该对象的监视器才能进入同步块或者同步方法，而没有获取到监视器的线程将会被阻塞在同步块和同步方法的入口处，进入BLOCK状态。</li>
</ul>
</li>
</ul>
</li>
<li><p>等待、通知机制的相关方法：</p>
<ul>
<li><code>notify()</code>:通知一个在对象上等待的线程，使其从wait()方法返回，而返回的前提是改线程获取到了对象的锁</li>
<li><code>notifyAll()</code>:通知所有等待在该对象上的线程</li>
<li><code>wait()</code>:调用该方法的线程进入WAITING状态，只有等待另外线程的通知或被中断才会返回，需要注意，调用wait()方法后，会释放对象的锁</li>
<li><code>wait(long)</code>:超时等待一段时间，如果没有通知，就超时返回</li>
<li><code>wait(long,int)</code>:对于超时时间更细粒度的控制</li>
</ul>
</li>
<li><p>调用wait()/notify()/notifyAll()需要注意的细节？</p>
<ul>
<li>调用wait()、notify()、notifyAll()时需要先调用对象加锁</li>
<li>调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程防止到对象的等待队列</li>
<li>notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或notifyAll()的线程释放锁之后，等待线程才有机会从wait()返回</li>
<li>notify()方法将等待队列中的一个等待线程从等待队列中移动到同步队列中，而notifyAll()方法则是将等待队列中所有线程全部移动到同步队列中，被移动的线程状态从WAITING变为BLOCKED</li>
<li>从wait()方法返回的前提是获得了调用对象的锁。</li>
</ul>
</li>
<li><p>等待/通知的经典范式？</p>
<ul>
<li>等待方<ul>
<li>获取对象的锁，如果条件不满足，调用对象的wait()方法，被通知后仍要检查条件。条件满足则执行对应的逻辑</li>
<li><code>synchronized(对象){ while(条件不满足){对象.wait} 条件满足，对应的处理逻辑;}</code></li>
</ul>
</li>
<li>通知方<ul>
<li>获得对象的锁，改变条件，通知所有等待在对象上的线程</li>
<li><code>synchronized(对象){ 改变条件；对象.notifyAll();}</code></li>
</ul>
</li>
</ul>
</li>
<li><p>管道输入、输出流(了解即可)</p>
<ul>
<li>主要用于线程之间的数据传输，而传输的媒介为内存</li>
<li>主要包括如下四种具体实现：<ul>
<li>PipedOutputStream</li>
<li>PipedInputStream</li>
<li>PipedReader</li>
<li>PipedWriter</li>
</ul>
</li>
</ul>
</li>
<li><p>Thread.join()的使用</p>
<ul>
<li>如果一个线程A执行了thread.join()语句，其含义是：当前线程A等待thread线程终止之后才从thread.join()返回。</li>
</ul>
</li>
<li><p>什么是ThreadLocal？</p>
<ul>
<li>线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这个结构被附带在线程上，即一个线程可以根据一个ThreadLocal对象查询绑定到这个线程上的一个值。</li>
<li>通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</li>
</ul>
</li>
</ol>
<h4 id="第五章-Java中的锁"><a href="#第五章-Java中的锁" class="headerlink" title="第五章 Java中的锁"></a>第五章 Java中的锁</h4><ol>
<li><p>Lock接口有什么作用？</p>
<ul>
<li>提供了与synchronized关键字类似的同步功能，只是在使用时需要显式地获取和释放锁。虽然缺少了隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以及超时获取锁等多种synchronized关键字锁不具备的同步特性。</li>
<li>Lock接口实现的锁机制，在finally里面要释放锁，目的是保证在获取到锁之后，最终能够被释放</li>
<li>Lock接口的实现基本都是通过聚合了一个同步器的子类来完成线程访问控制的。</li>
</ul>
</li>
<li><p>Lock接口提供的synchronized关键字不具备的哪些特性？</p>
<ul>
<li>尝试非阻塞地获取锁：当前线程尝试获取锁，如果这一时刻锁没有被其他线程获取到，则成功获取并持有锁</li>
<li>能被中断地获取锁：与synchronized不同，获取到锁的线程能响应中断，当获取到锁的线程被中断时，中断异常将会被抛出，同时锁会被释放</li>
<li>超时获取锁：在指定的截止时间之前获取锁，如果截止时间到了仍旧无法获取锁，则返回。</li>
</ul>
</li>
<li><p>Lock常用API</p>
<ul>
<li>lockInterruptibly()：可中断地获取锁，和lock()方法的不同之处在于该方法会响应中断，即在锁的获取中可以中断您当前线程。</li>
<li>tryLock()：尝试非阻塞的获取锁，调用该方法后立即返回，如果能够获取则返回true，否则返回false</li>
<li>tryLock(long):超时获取锁，当前线程在以下3种情况下会返回<ul>
<li>当前线程在超时时间内获得了锁</li>
<li>当前线程在超时时间内被中断</li>
<li>超时时间结束，返回false</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是队列同步器？如何使用？</p>
<ul>
<li>是用来构建锁或者其他同步组件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获取线程的排队工作</li>
<li>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状态，在抽象方法的实现过程中需要对同步状态进行更改，使用同步器提供的3个方法(getState()、setState(int newState)、compareAndSetState(int expect,int update))来进行操作。</li>
</ul>
</li>
<li><p>同步器和锁之间的关系？</p>
<ul>
<li>同步器是实现锁的关键，在锁的实现中聚合同步器，利用同步器实现锁的语义。</li>
<li>锁是面向使用者的，它定义了使用者与锁交互的接口，隐藏了实现细节；同步器面向的是锁的实现着，简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</li>
<li>锁和同步器很好地隔离了使用者和实现者所需关注的领域。</li>
</ul>
</li>
<li><p>队列同步器是如何完成线程同步的？(了解即可，暂时觉得没必要深入)</p>
<ul>
<li>同步队列</li>
<li>独占式同步状态获取与释放</li>
<li>共享式同步状态获取与释放</li>
<li>独占式超时获取同步状态</li>
</ul>
</li>
<li><p>什么是重入锁ReentrantLock？</p>
<ul>
<li>支持重进入的锁，表示该锁能过支持一个线程对资源的重复加锁。</li>
<li>synchronized关键字隐式的支持重进入</li>
<li>ReentrantLock在调用lock()方法的时候，已经获取到锁的线程能够再次调用lock()方法获取锁而不被阻塞</li>
<li>这种锁还支持获取锁时的公平和非公平性选择<ul>
<li>如果在绝对时间上，先对锁进行获取的请求一定先被满足，那么这个锁是公平的，反之是不公平的。</li>
<li>公平的锁机制旺旺没有非公平的效率高，但是公平锁能够减少饥饿发生的概率。</li>
</ul>
</li>
</ul>
</li>
<li><p>ReentrantLock是如何实现重进入和公平性获取锁的特性的？</p>
<ul>
<li>重进入是指任意线程在获取到之后能够再次获取该锁而不会被锁所阻塞(ReentrantLock是通过组合自定义同步器来实现锁的获取和释放的。)：<ul>
<li>线程再次获取锁：锁需要识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取</li>
<li>锁的最终释放：线程重复n次获取了锁，随后在第n次释放该所后，其他线程能够获取到该所。</li>
</ul>
</li>
<li>如果一个锁是公平的，那么锁的获取顺序就应该复合物清奇肚饿绝对时间顺序。ReentrantLock实现的tryAcquire方法里面可以去区分实现公平还是非公平的获取锁。</li>
</ul>
</li>
<li><p>什么是读写锁ReentrantReadWriteLock？</p>
<ul>
<li>读写锁在同一个时刻可以允许多个读线程访问，但是在写线程访问的时候，所有的读线程和其他写线程均被阻塞。</li>
<li>读写锁维护了一对锁，一个读锁，一个写锁，通过分离读锁和写锁，使得并发性相比一般的排它锁有了很大提升。</li>
</ul>
</li>
<li><p>LockSupport工具</p>
<ul>
<li>当需要阻塞或唤醒一个线程的时候，都会使用LockSupport工具类来完成相应工作。</li>
<li>LockSupport定义了一组以park开头的方法用来阻塞当前线程，以及unpark方法来唤醒一个被阻塞的线程。</li>
</ul>
</li>
<li><p>Condition接口</p>
<ul>
<li>任意一个Java对象，都拥有一组监视器方法，主要包括wait()、waint(long)、notify()、notifyAll()方法，这些方法与synchronized同步关键字配合，可以实现等待/通知模式。</li>
<li>Condition接口也提供了类似Object的监视器方法，与Lock配合可以实现等待/通知模式。(await方法和signal方法)</li>
</ul>
</li>
<li><p>如何使用Condition和Lock实现等待/通知模式？</p>
<ul>
<li>await方法调用后，当前线程会释放锁并在此等待，而其他线程调用Condition对象的signal方法，通知当前线程后，当前线程才从await方法返回，并且在返回前已经获取了锁。</li>
</ul>
</li>
</ol>
<h4 id="第六章-Java并发容器和框架"><a href="#第六章-Java并发容器和框架" class="headerlink" title="第六章 Java并发容器和框架"></a>第六章 Java并发容器和框架</h4><ol>
<li><p>ConcurrentHashMap的实现原理与使用？</p>
<ul>
<li>ConcurrentHashMap是线程安全且高效的HashMap</li>
<li>由Segment数组结构和HashEntry数组结构组成。<ul>
<li>segment是一种可重入锁，在ConcurrentHashMap中扮演锁的角色。一个ConcurrentHashMap里包含一个Segment数组。<ul>
<li>Segment和HashMap类似，是一种数组和链表结构</li>
</ul>
</li>
<li>HashEntry用于存储键值对数据。</li>
</ul>
</li>
<li>一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素，每个Segment守护者一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得与它对应的Segment锁。 </li>
</ul>
</li>
<li><p>为什么要使用ConcurrentHashMap？</p>
<ul>
<li>HashMap是线程不安全的<ul>
<li>并发执行put操作会引起死循环，因为多线程会导致HashMap的Entry链表形成环形数据结构，一旦形成环形数据结构，Entry的next节点用于不为空，就会产生死循环获取Entry</li>
<li>1.8版本有修复死循环问题，但是并发还是有问题，多线程情况下还是要使用ConcurrentHashMap</li>
</ul>
</li>
<li>HashTable效率低下<ul>
<li>HashTable使用synchronized来保证线程安全，但是线程竞争激烈的情况下，HashTable的效率非常低下，所有访问HashTable的线程都必须竞争同一把锁。</li>
<li>HashTable每个成员方法前面用synchronized修饰，表示锁的是HashTable的实例对象，每次HashTable的使用竞争的都是这个实例对象的锁，所以效率不高。</li>
</ul>
</li>
<li>ConcurrentHashMap的锁分段技术可有效提升并发访问率<ul>
<li>容器里有多把锁，每一把锁用于锁容器其中一部分数据，那么多线程访问容器里不同数据段的数据时，线程间就不会存在锁竞争，从而有效提高并发访问效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是ConcurrentHashMap使用的锁分段技术？</p>
<ul>
<li>首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
</ul>
</li>
<li><p>ConcurrentHashMap的初始化</p>
<ul>
<li>通过initialCapacity、loadFactor和concurrencyLevel等几个参数来初始化segment数组、段偏移量segmentShift、段掩码segmentMash和每个segment里的HashEntry数组来实现。<ul>
<li>初始化segments数组，长度是通过concurrencyLevel计算得出的。为了能通过按位与的散列算法来定位segments数组的索引，必须保证segments数组的长度是2的N次方。</li>
<li>初始化segmentShift和segmentsMasj。这两个全局变量需要在定位segment时的散列算法里使用。</li>
<li>初始化每个segment</li>
</ul>
</li>
</ul>
</li>
<li><p>定位Segment</p>
<ul>
<li>ConcurrentHashMap使用分段锁Segment来保护不同段的数据，那么在插入和获取元素的时候，必须先通过散列算法定位到Segment。</li>
<li>首先使用算法对元素的hashCode进行一次再散列<ul>
<li>目的是减少散列冲突，使元素能够均匀地分布在不同的Segment上，从而提高容器的存取效率。</li>
</ul>
</li>
</ul>
</li>
<li><p>ConcurrentHashMap 的三种操作：</p>
<ul>
<li>get操作<ul>
<li>先经过一次再散列，然后使用这个散列值通过散列运算定位到Segment，再通过散列算法定位到元素。</li>
<li>高效之处在于整个get过程不需要加锁，除非读到的值是空，才会加锁重读。<ul>
<li>get方法里将要使用的共享变量都定义成volatile类型，能够在线程之间保持可见性，能够被多线程同时读，并且保证不会读到过期的值，但是只能被单线程写。</li>
</ul>
</li>
</ul>
</li>
<li>put操作<ul>
<li>首先定位到Segment，然后在Segment里进行插入操作。<ul>
<li>第一步判断是否需要对Segment里的HashEntry数组进行扩容<ul>
<li>hashMap在插入元素后判断元素是否已经到达容量的，如果到达了就扩容，但是这可能存在后面就不用再插入元素了，就进行了一次无效的扩容。</li>
</ul>
</li>
<li>第二步定位添加元素的位置，然后将其放在HashEntry数组里。</li>
</ul>
</li>
</ul>
</li>
<li>size操作<ul>
<li>直接将Segment的count相加，在累加，可能在这两步之间发生了变化，虽然概率比较低。</li>
<li>ConcurrentHashMap的做法是，先尝试2次通过不锁住Segment的方式来统计各个Segment的大小，如果统计的过程中，容器的count发生了变化，则再采用加锁的方式来统计所有Segment的大小。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何实现一个线程安全的队列？</p>
<ul>
<li>一种是使用阻塞算法<ul>
<li>可以用一个锁或两个锁来实现</li>
</ul>
</li>
<li>一种是使用非阻塞算法<ul>
<li>可以使用循环CAS的方式实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是ConcurrentLinkedQueue？(暂时了解即可)</p>
<ul>
<li>ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，添加在队列尾部，获取队列头部的元素。</li>
<li>它采用了wait-free算法(CAS算法)</li>
</ul>
</li>
<li><p>什么是阻塞队列？</p>
<ul>
<li>阻塞队列是一个支持两个附加操作的队列。这两个附加的操作支持阻塞的插入和移除方法<ul>
<li>支持阻塞的插入方法：当队列满的时候，队列会阻塞插入元素的线程，直到队列不满</li>
<li>支持阻塞的移除方法：队列为空的时候，获取元素的线程会等待队列变为非空</li>
</ul>
</li>
<li>常用语生产者和消费者的场景。 </li>
</ul>
</li>
<li><p>Java中的阻塞队列</p>
<ul>
<li>7种阻塞队列<ul>
<li>ArrayBlockingQueue：数组结构组成的有界阻塞队列</li>
<li>LinkedBlockingQueue：链表结构组成的有界阻塞队列</li>
<li>PriorityBlockingQueue：支持优先级排序的无界阻塞队列</li>
<li>DelayQueue：使用优先级队列实现的无界阻塞队列</li>
<li>SynchronousQueue：不存储元素的阻塞队列</li>
<li>LinkedTransferQueue：链表结构组成的无界阻塞队列</li>
<li>LinkedBlockingDeque：链表结构组成的双向阻塞队列</li>
</ul>
</li>
<li>实现原理：<ul>
<li>使用通知模式实现：当生产者往满的队列里添加元素的时候会阻塞住生产者，当消费者消费了一个队列中的元素后，会通知生产者当前队列可用。</li>
</ul>
</li>
</ul>
</li>
<li><p>Fork/Join框架</p>
<ul>
<li>用于并行执行任务的框架，是一个把大任务分割成若干个小任务，最终汇总每个小任务结果后得到大任务结果的框架。</li>
<li>Fork就是把一个大任务切分为若干子任务并行的执行</li>
<li>Join就是合并这些子任务的执行结果，最后得到这个大任务的结果。</li>
</ul>
</li>
<li><p>什么是工作窃取算法？</p>
<ul>
<li>是指某个线程从其他队列中窃取任务来执行。</li>
<li>大任务分割为互不依赖的子任务，为了减少线程间的竞争，把子任务分别放到不同的队列中，并为每个队列创建一个单独的线程来执行队列里的任务；有的线程会先完成队列任务，就需要从其他线程的队列中窃取任务来执行，为了减少这种情况下的竞争，通常使用双端队列来实现，被窃取任务线程永远从双端队列的头部拿任务执行，而窃取任务的线程永远从双端队列的尾部拿任务执行。</li>
<li>优点是，利用线程进行并行计算，减少了线程间的竞争</li>
<li>缺点是，某些情况下还是存在竞争，如双端队列中只有一个任务的时候</li>
</ul>
</li>
</ol>
<h4 id="第七章-Java中的13个原子操作类"><a href="#第七章-Java中的13个原子操作类" class="headerlink" title="第七章 Java中的13个原子操作类"></a>第七章 Java中的13个原子操作类</h4><ol>
<li><p>12个类，属于4中类型的原子更新方式：</p>
<ul>
<li>原子更新基本类型</li>
<li>原子更新数组</li>
<li>原子更新引用</li>
<li>原子更新属性</li>
</ul>
</li>
<li><p>原子更新基本类型</p>
<ul>
<li>三个类<ul>
<li>AtomicBoolean</li>
<li>AtomicInteger</li>
<li>AtomicLong</li>
</ul>
</li>
<li>提供的方法：<ul>
<li>addAndGet</li>
<li>compareAndSet</li>
<li>getAndIncrement</li>
<li>lazySet</li>
<li>getAndSet </li>
</ul>
</li>
<li>可以通过Unsafe提供的3种CAS方法：compareAndSwapObject、compareAndSwapInt和compareAndSwapLong实现其他基本类型的原子更新</li>
</ul>
</li>
<li><p>原子更新数组</p>
<ul>
<li>三个类<ul>
<li>AtomicIntegerArray</li>
<li>AtomicLongArray</li>
<li>AtomicReferenceArray</li>
</ul>
</li>
<li>提供的方法：<ul>
<li>addAndGet</li>
<li>compareAndSet</li>
</ul>
</li>
</ul>
</li>
<li><p>原子更新引用类型</p>
<ul>
<li>三个类<ul>
<li>AtomicReference：原子更新引用类型</li>
<li>AtomicReferenceFieldUpdater：原子更新引用类型的字段</li>
<li>AtomicMarkableReference：原子更新带有标记位的引用类型</li>
</ul>
</li>
</ul>
</li>
<li><p>原子更新字段类</p>
<ul>
<li>三个类<ul>
<li>AtomicIntegerFieldUpdater：原子更新整型的字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整型字段的更新器</li>
<li>AtomicStampedReference：原子更新带版本号的引用类型</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第八章-Java并发工具类"><a href="#第八章-Java并发工具类" class="headerlink" title="第八章 Java并发工具类"></a>第八章 Java并发工具类</h4><ol>
<li><p>CountDownLatch是什么？</p>
<ul>
<li>CountDownLatch允许一个或多个先等待其他线程完成操作</li>
<li>CountDownLatch实现类似join的功能，并且比join的功能更多</li>
</ul>
</li>
<li><p>如何使用CountDownLatch？</p>
<ul>
<li>构造函数传入int值，等待N个点完成就传入N</li>
<li>每次调用countDown方法，N就会减1，CountDownLatch的await方法会阻塞当前线程，知道N变成0.这里的N个点，可以是N个线程，也可以是1个线程里面的N个步骤，只需要将这个CountDownLatch的引用传递到线程里即可</li>
<li>如果不让主线程一直等待，可以使用带指定时间的await方法，这个方法等待特定时间后，就不会再继续阻塞当前线程。</li>
</ul>
</li>
<li><p>join方法的作用和实现原理？</p>
<ul>
<li>join用于让当前执行线程等待join线程执行结束，其实现原理是不同检查join线程是否存活，如果join线程存活，则让当前线程永远等待，知道join线程终止后，线程的this.notify方法会被调用。</li>
</ul>
</li>
<li><p>什么是同步屏障CyclicBarrier？</p>
<ul>
<li>可循环使用的屏障</li>
<li>让一组线程到达一个屏障时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</li>
</ul>
</li>
<li><p>如何使用CyclicBarrier？有哪些应用场景？</p>
<ul>
<li>构造函数传入int，表示屏障拦截的线程数量，每个线程调用await方法告诉CyclicBarrier到达屏障了，然后当前线程被阻塞。有参数表示的数量线程到达屏障以后，线程才会执行，否则会一直等待下去。</li>
<li>高级构造函数传入int和Runnable，用于在线程到达屏障的时候，优先执行Runnable方便处理更复杂的业务场景。</li>
<li>可用于多线程计算数据，最后合并计算结果的场景</li>
</ul>
</li>
<li><p>CyclicBarrier和COuntDownLatch的区别？</p>
<ul>
<li>CountDownLatch的计数器只能使用一次，而CyclicBarrier的计数器可以使用reset()方法重置。</li>
<li>CyclicBarrier还提供其他有用的方法，如<ul>
<li>getNumberWaiting方法可以获得Cyclic-Barrier阻塞的线程数量</li>
<li>isBroken()用来了解阻塞的线程是否被中断。</li>
</ul>
</li>
</ul>
</li>
<li><p>控制并发线程数的Semaphore()信号量</p>
<ul>
<li>Semaphore是用来控制同时访问特定资源的线程数量，它通过协调各个线程，以保证合理的使用公共资源</li>
<li>Semaphore可以用于做流量控制，特别是公共资源有限的应用场景。</li>
</ul>
</li>
<li><p>线程间交换数据的Exchanger</p>
<ul>
<li>用于线程间协作的工具类，进行线程间的数据交换。</li>
<li>提供一个同步到，在这个同步点，两个线程可以通过exchange方法交换数据。两个线程通过exchange方法交换数据，如果第一个线程先执行exchange方法，它会一直等待第二个线程也执行exchange方法。</li>
<li>Exchanger可以用于遗传算法，也可以用于校对工作</li>
</ul>
</li>
</ol>
<h4 id="第九章-Java中的线程池"><a href="#第九章-Java中的线程池" class="headerlink" title="第九章 Java中的线程池"></a>第九章 Java中的线程池</h4><ol>
<li><p>合理使用线程池能够带来的3个好处</p>
<ul>
<li>降低资源消耗<ul>
<li>通过重复利用已创建的线程，降低线程创建和销毁造成的消耗</li>
</ul>
</li>
<li>提高响应速度<ul>
<li>当任务到达时，任务可以不需要等到线程创建就能立即执行</li>
</ul>
</li>
<li>提高线程的可管理性<ul>
<li>线程是稀缺资源，使用功能线程池可以统一分配、调优和监控。</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池的实现原理</p>
<ul>
<li>新任务提交到线程池的时候，处理流程如下：<ul>
<li>如果当前运行的线程少于corePoolSize，则创建新线程来执行任务(需要获取全局锁)</li>
<li>如果运行的线程大于或等于corePoolSize，则将任务加入BlockingQueue</li>
<li>如果无法将任务加入BlockQueue(队满)，则创建新的线程来处理任务(需要获取全局锁)</li>
<li>如果创建新线程将使当前运行的线程超出maximumPoolSize，任务将被拒绝，并调用RejectedExecutionHandler.rejectedExecution()方法</li>
</ul>
</li>
<li>之所以这样设计，是尽可能避免获取全局锁，加入任务队列不需要获取全局锁。</li>
<li>线程池中的线程执行任务分两种情况：<ul>
<li>在execute()方法中创建一个线程时，会让这个线程执行当前任务</li>
<li>这个线程执行完当前任务后，会反复从BlockingQueue获取任务来执行。</li>
</ul>
</li>
</ul>
</li>
<li><p>线程池如何使用？如何创建？提交任务？关闭线程池？合理地配置线程池？</p>
<ul>
<li>创建线程池：<ul>
<li><code>new ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,milliseconds,runnableTaskQueue,handler)</code><ul>
<li>corePoolSize:线程池的基本大小，也可理解为核心线程数的大小.(如果调用了线程池的prestartAllCoreThreads方法，线程池会提前穿件并启动所有基本线程)</li>
<li>maximumPoolSize：线程池的最大数量</li>
<li>runnableTaskQueue：任务队列，用于保存等待执行的任务的阻塞队列。<ul>
<li>ArrayBlockingQueue</li>
<li>LinkedBlockingQueue</li>
<li>SynchronousQueue</li>
<li>PriorityBlockingQueue，</li>
</ul>
</li>
<li>RejectedExecutionHandler：饱和策略，队列和线程池都满了的时候，采取的策略，<ul>
<li>默认是AbortPolicy：直接抛出异常</li>
<li>CallerRunsPolicy：只用调用者所在线程来执行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近一个任务，并执行当前任务</li>
<li>DiscardPolicy：不处理，丢弃掉</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>向线程池提交任务：<ul>
<li>execute()：提交不需要返回值的任务，无法判断任务是否被线程池执行成功</li>
<li>submit() ：提交需要返回值的任务，线程池会返回一个future类型的对象，通过这个future对象可以判断任务是否执行成功，通过get()方法来获取返回值，get()方法会阻塞当前线程直到任务完成，而get(long timeout,TimeUnit unit)方法会阻塞当前线程一段时间后立即返回，这个时候可能任务没有执行完(这个和flutter有点类似啊，学习了。)</li>
</ul>
</li>
<li>关闭线程池<ul>
<li>可以通过调用线程池的shutdown或shutdownNow方法来关闭线程池。<ul>
<li>shutdown：将线程池状态设置成SHUTDOWN状态，然后中断所有没有正在执行任务的线程</li>
<li>shutdownNow：将线程池的状态设置成STOP，然后尝试停止所有正在执行或暂停任务的线程，并返回等待执行任务的列表</li>
</ul>
</li>
<li>通常调用shutdown方法来关闭线程池，如果任务不一定要执行完，则可以调用shutdownNow方法</li>
</ul>
</li>
<li>合理地配置线程池<ul>
<li>CPU密集型任务赢配置尽量少的线程</li>
<li>I/O密集型任务线程则可以配置尽可能多的线程</li>
<li>优先级不同的任务可以使用优先级队列来处理</li>
<li>建议使用有界队列，能增加系统的稳定性和预警能力。</li>
</ul>
</li>
<li>线程池的监控<ul>
<li>可以通过线程池提供的参数进行监控<ul>
<li>taskCount、completedTaskCount等</li>
</ul>
</li>
<li>也可以通过扩展线程池进行监控<ul>
<li>自定义线程池、重写线程池idebeforeExecute、afterExecute和terminated方法等</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第十章-Executor框架"><a href="#第十章-Executor框架" class="headerlink" title="第十章 Executor框架"></a>第十章 Executor框架</h4><ol>
<li><p>Java的线程即是工作单元，也是执行机制。从Java 1.5开始，把工作单元与执行机制分离开，工作单元包括Runnable和Callable，而执行机制有Executor框架提供。应用程序通过Executor框架控制上层的调度，而下层的调度由操作系统内核控制，下层的调度不受应用程序的控制。</p>
</li>
<li><p>Executor框架主要包括三部分</p>
<ul>
<li>任务<ul>
<li>包括被执行任务需要实现的接口</li>
</ul>
</li>
<li>任务的执行<ul>
<li>包括任务执行机制的核心接口Executor，以及集成自Executor的ExecutorService接口。(ThreadPoolExecutor和ScheduledThreadPoolExecutor)</li>
</ul>
</li>
<li>异步计算的结果<ul>
<li>包括接口Future和实现Future接口的FutureTask类</li>
</ul>
</li>
</ul>
</li>
<li><p>Executor框架的使用流程</p>
<ul>
<li>主线程首先创建实现Runnable或者Callable接口的任务对象类。工具类Executors可以把一个Runnable对象封装为一个Callable对象或Executors.callable</li>
<li>然后可以把Runnable对象直接交给ExecutorService执行execute；或者也可以把Runnable对象或Callable对象提交给ExecutorService执行submit<ul>
<li>如果是执行submit，ExecutorService将返回一个实现Future接口的对象，由于FutureTask实现了Runnable，程序员也可以直接创建FutureTask，然后直接交给ExecutorService执行</li>
</ul>
</li>
<li>最后主线程可以执行FutureTask.get()方法来等待任务执行完成。也可以执行FutureTask.cancel来取消任务的执行。</li>
</ul>
</li>
<li><p>ThreadPoolExecutor</p>
<ul>
<li>线程池的实现类</li>
<li>见底部分类图</li>
</ul>
</li>
<li><p>ScheduledThreadPoolExecutor</p>
<ul>
<li>ScheduledThreadPoolExecutor会把调度任务(ScheduledFutureTask)放到一个DelayQueue中</li>
<li>DelayQueue封装了一个PriorityQueue，这个优先级队列会对队列中的Scheduled-FutureTask进行排序依次根据time、sequenceNumber来排序。</li>
</ul>
</li>
<li><p>FutureTask</p>
<ul>
<li>FutureTask除了实现Future接口外，还实现了Runnable接口。因此FutureTask可以交给Executor执行，也可以由调用线程直接执行。</li>
<li>三种状态：<ul>
<li>未启动：FutureTask.run()未被执行之前。</li>
<li>已启动：FutureTask.run()方法被执行的过程中</li>
<li>已完成：FutureTask.run()方法执行完后正常结束；或被取消；或执行run方法抛出异常而异常结束</li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>类型</th>
<th>corePool</th>
<th>maximumPool</th>
<th>BlockingQueue</th>
<th>keepAliveTime</th>
</tr>
</thead>
<tbody><tr>
<td>FixedThreadPool</td>
<td>固定</td>
<td>/</td>
<td>LinkedBlockingQueue(无界队列)</td>
<td>0s</td>
</tr>
<tr>
<td>SingleThreadExecutor</td>
<td>1</td>
<td>1</td>
<td>LinkedBlockingQueue</td>
<td>0s</td>
</tr>
<tr>
<td>CachedThreadPool</td>
<td>0</td>
<td>Integet.MAX_VALUE</td>
<td>SynchronousQueue(没有容量的阻塞)</td>
<td>60s</td>
</tr>
</tbody></table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/08/27/book-Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E8%89%BA%E6%9C%AF/" data-id="ck8e3fmti00if27qy5pm34nip" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-leetcode-interview-total" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/07/12/leetcode-interview-total/" class="article-date">
  <time datetime="2018-07-12T10:19:53.000Z" itemprop="datePublished">2018-07-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/07/12/leetcode-interview-total/">LeetCode 热题加油</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Must done List</p>
        
          <p class="article-more-link">
            <a href="/mLixin.github.io/2018/07/12/leetcode-interview-total/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/07/12/leetcode-interview-total/" data-id="ck8e3fmso00i027qyduojd9yb" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/LeetCode/" rel="tag">LeetCode</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-GeekBang-Java核心技术36讲" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/05/21/GeekBang-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2/" class="article-date">
  <time datetime="2018-05-21T08:01:11.000Z" itemprop="datePublished">2018-05-21</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/Java/">Java</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/05/21/GeekBang-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2/">Geek Java核心技术36讲 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="第一讲-谈谈你对Java平台的理解"><a href="#第一讲-谈谈你对Java平台的理解" class="headerlink" title="第一讲 谈谈你对Java平台的理解"></a>第一讲 谈谈你对Java平台的理解</h4><ol>
<li><p>谈谈你对Java平台的理解？”Java是解释执行”这句话正确码？</p>
<ul>
<li>Java是面向对象的语言，最显著的特性有两个方面：<ul>
<li>书写一次，到处运行：有跨平台的能力</li>
<li>垃圾收集 ：通过垃圾收集器回收分配内存，大部分情况下，程序员不需要自己操心内存的分配和回收。</li>
</ul>
</li>
<li>“Java是解释执行”这句话说法不太准确。Java源代码首先通过Javac编译成字节码，然后在运行时，通过Java虚拟机内嵌的解释器将字节码转换成最终的机器码。但是有些虚拟机提供了JIT编译器，就是通常说的动态编译器，JIT能够在运行的时候将热点代码编译成机器码，这种情况下部分热点代码就属于编译执行，而不是解释执行了。</li>
</ul>
</li>
<li><p>“Compile once,run anywhere”的理解？</p>
<ul>
<li>C语言的缺点：C语言程序经常需要调用操作系统层面的api，不同操作系统，api一般不同。为了支持多平台，C语言程序的源文件需要根据不同平台修改多次，宣传语原文是”write once,run anywhere”，焦点在对源文件的修改上。</li>
</ul>
</li>
</ol>
<h4 id="第二讲-Exception和Error有什么区别？"><a href="#第二讲-Exception和Error有什么区别？" class="headerlink" title="第二讲 Exception和Error有什么区别？"></a>第二讲 Exception和Error有什么区别？</h4><ol>
<li>对比一下Exception和Error？<ul>
<li>Exception和Error都是继承Throwable类，在Java中只有Throwable类型的实例可以被throw或catch，它是异常处理机制的基本组成类型。Exception是程序正常运行中可以预料的意外情况，可能并且应该被捕获，进行相应处理。Error是指在正常情况下，不大可能出现的情况，绝大部分的Error都会导致程序处于非正常的、不可恢复状态，不便于也不需要捕获。</li>
</ul>
</li>
<li><h2 id="运行时异常和一般异常有什么区别？"><a href="#运行时异常和一般异常有什么区别？" class="headerlink" title="运行时异常和一般异常有什么区别？  "></a>运行时异常和一般异常有什么区别？  </h2></li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/21/GeekBang-Java%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF36%E8%AE%B2/" data-id="ck8e3fmmi000327qyhijf8dgr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-GeekBang-趣谈网络协议" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/05/20/GeekBang-%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" class="article-date">
  <time datetime="2018-05-20T07:57:31.000Z" itemprop="datePublished">2018-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/05/20/GeekBang-%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/">Geek 趣谈网络协议 学习笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="第1讲-为什么要学习网络协议"><a href="#第1讲-为什么要学习网络协议" class="headerlink" title="第1讲 为什么要学习网络协议"></a>第1讲 为什么要学习网络协议</h4><ol>
<li>协议三要素是什么？<ul>
<li>语法：一段内容要符合一定的规则和格式</li>
<li>语义：要代表某种意义</li>
<li>顺序：先干啥，后干啥
        
          <p class="article-more-link">
            <a href="/mLixin.github.io/2018/05/20/GeekBang-%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/#more">Read More</a>
          </p>
        
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/20/GeekBang-%E8%B6%A3%E8%B0%88%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" data-id="ck8e3fms900ha27qy7c30hoh2" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="tag">网络协议</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-book-图解HTTP" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/05/20/book-%E5%9B%BE%E8%A7%A3HTTP/" class="article-date">
  <time datetime="2018-05-20T05:45:40.000Z" itemprop="datePublished">2018-05-20</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/05/20/book-%E5%9B%BE%E8%A7%A3HTTP/">图解HTTP 读书笔记</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>太通俗</p>
<h4 id="第一章-了解Web及网络基础"><a href="#第一章-了解Web及网络基础" class="headerlink" title="第一章 了解Web及网络基础"></a>第一章 了解Web及网络基础</h4><ol>
<li><p>网络分层和各层的作用？</p>
<ul>
<li>应用层：决定了向用户提供应用服务时通信的活动<ul>
<li>HTTP协议</li>
</ul>
</li>
<li>传输层：对上层应用层，提供处于网络连接中的两台计算机之间的数据传输<ul>
<li>TCP协议(传输控制协议)、UDP协议(用户数据报协议)</li>
</ul>
</li>
<li>网络层：用来处理在网络上流动的数据包。</li>
<li>链路层：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC，及光纤等物理可见部分。硬件上的范畴均在链路层的作用范围之内。</li>
<li>物理层：不属于TCP/IP协议族里面的。</li>
</ul>
</li>
<li><p>HTTP请求流程？</p>
<ul>
<li>发送端，应用层发送HTTP数据，传输层在这个基础上加上TCP首部，网络层加上IP首部，链路层加上以太网首部</li>
<li>接收端，接收到数据包后，链路层拿下以太网首部，网络层拿下IP首部，传输层拿下TCP首部，应用层拿到HTTP数据。</li>
</ul>
</li>
<li><p>什么是IP协议</p>
<ul>
<li>位于网络层</li>
<li>负责传输，把各种数据包传送给对方</li>
</ul>
</li>
<li><p>什么是ARP协议？</p>
<ul>
<li>用以解析地址的协议，根据通信方的IP地址，就可以反差出对应的MAC地址。</li>
</ul>
</li>
<li><p>什么是TCP协议？三次握手过程是怎样的？</p>
<ul>
<li>传输层</li>
<li>提供可靠的字节流服务(为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理，而可靠的传输服务是指，能够把数据准确可靠得传给对方。)</li>
<li>三次握手<ul>
<li>发送端首先发送一个带SYN标志的数据包给对方</li>
<li>接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息</li>
<li>发送端再回传一个ACK标志的数据包，代表握手结束。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是DNS服务？</p>
<ul>
<li>和HTTP协议一样，位于应用层</li>
<li>提供域名到IP地址之间的解析服务</li>
</ul>
</li>
<li><p>HTTP请求流程中，各协议起到的作用</p>
<ul>
<li>DNS服务：通过域名解析到对应的IP地址</li>
<li>HTTP协议：生成针对目标服务器的HTTP请求报文</li>
<li>TCP协议：为了方便通信，将HTTP请求报文分割成报文段，把每个报文段可靠的传给对方</li>
<li>IP协议：搜索对方的地址，一边中转，一边传送</li>
<li>(接收端)TCP协议：从对方那里接收到报文段，按顺序将到达的报文段重组为请求报文</li>
<li>(接收端)HTTP协议：对Web请求的内容的处理。</li>
</ul>
</li>
</ol>
<h4 id="第二章-简单的HTTP协议"><a href="#第二章-简单的HTTP协议" class="headerlink" title="第二章 简单的HTTP协议"></a>第二章 简单的HTTP协议</h4><ol>
<li><p>客户端发给HTTP服务器端的请求报文内容包括哪些？</p>
<ul>
<li>由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</li>
<li>如<code>GET /index.htm HTTP/1.1 Host:xxx</code>：<ul>
<li><code>GET</code>表示请求服访问服务器的类型，称为method</li>
<li><code>/index.htm</code>表示请求访问的资源对象，也叫请求URI。</li>
<li><code>HTTP/1.1</code>表示HTTP的版本号</li>
</ul>
</li>
</ul>
</li>
<li><p>服务端返回给客户端的响应报文包括哪些内容？</p>
<ul>
<li>由协议版本、状态码、泳衣解释状态码的原因短语、可选的响应首部字段以及实体主题构成</li>
<li>如<code>HTTP/1.1 200 OK Data:xxx Content-Type:xxx</code><ul>
<li><code>HTTP/1.1</code>表示服务器对应的HTTP版本</li>
<li><code>2002 OK</code>表示请求的处理结果的状态码和原因短语</li>
<li><code>Date:xxx</code>显示了响应的日期时间，是首部字段内的一个属性</li>
</ul>
</li>
</ul>
</li>
<li><p>HTTP协议有什么特点？</p>
<ul>
<li>HTTP是一种不保存状态，即无状态协议。HTTP协议自身不对请求和响应之间的通信状态进行保存，也就是说，在HTTP这个级别，协议对于发送过的请求或响应都不做持久化处理。</li>
<li>为了实现期望的保持状态的功能，引入了Cookie技术，有了Cookie再用HTTP协议通信，就可以管理状态了。</li>
</ul>
</li>
<li><p>HTTP/1.1中可以使用的method都有哪些？</p>
<ul>
<li>GET：获取资源</li>
<li>POST：传输实体主体</li>
<li>PUT：传输文件</li>
<li>HEAD：获取报文首部</li>
<li>DELETE：删除文件</li>
<li>OPTIONS：询问支持的方法</li>
<li>TRACE：追踪路径</li>
<li>CONNECT：要求用隧道协议连接代理</li>
</ul>
</li>
<li><p>一次TCP连接可以进行几次HTTP请求？</p>
<ul>
<li>以前的版本一次请求建立连接后，请求响应完会断开连接</li>
<li>HTTP/1.1出现了持久连接，HTTP keep-alive，持久连接减少了TCP连接的重复建立和断开所造成的额外开销，减轻服务器的负载；同时减少了开销的时间，使HTTP请求和响应能够更早的结束。</li>
<li>HTTP/1.1中默认都是持久连接。</li>
</ul>
</li>
<li><p>什么是管线化？有什么作用？</p>
<ul>
<li>以前发送请求后续等待并受到响应后才能发送下一个请求。管线化技术出现后，不用等待响应也可以直接发送下一个请求</li>
</ul>
</li>
<li><p>什么是Cookie？</p>
<ul>
<li>HTTP是无状态协议，不对之前发生过的请求和响应状态进行管理。如果要求登录认证的web页面本身无法进行状态的管理，那么每次跳转新页面就要再次登录，或者要在每次请求报文中附加参数来管理登录状态。<ul>
<li>优点是，可以减少服务器的CPU及内存资源的消耗；协议简单，方便应用在各种场景里。</li>
</ul>
</li>
<li>为了解决这个矛盾，引入了Cookie，通过在请求和响应报文中写入Cookie信息来控制客户端的状态。</li>
<li>Cookie会根据从服务器端发送的响应报文中一个Set-Cookie的首部字段信息，通知客户端保存Cookie。下次客户端再发送请求的时候，会自动在请求报文中加入Cookie值后发送出去。服务器拿到Cookie后，会去检查是从哪个客户端发来的连接请求，然后得到之前的状态信息。 </li>
</ul>
</li>
</ol>
<h4 id="第三章-HTTP报文内的HTTP信息"><a href="#第三章-HTTP报文内的HTTP信息" class="headerlink" title="第三章 HTTP报文内的HTTP信息"></a>第三章 HTTP报文内的HTTP信息</h4><ol>
<li><p>HTTP报文都包括哪些内容？</p>
<ul>
<li>分为请求报文和响应报文</li>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态行：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含请求和响应的各种条件和属性的各类首部<ul>
<li>通用首部、请求首部、响应首部和实体首部等</li>
</ul>
</li>
<li>其他：包含HTTP的RFC里未定义的首部</li>
</ul>
</li>
<li><p>报文和实体是什么？两者有什么差异？</p>
<ul>
<li>报文是HTTP通信的基本单位，由8位组字节流组成，通过HTTP通信传输</li>
<li>实体是作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</li>
<li>通常，报文主题等于实体主题。只有当传输中进行编码操作的时候，实体主题的内容发生变化，才导致它和报文主题产生差异。</li>
</ul>
</li>
<li><p>什么是HTTP协议中的内容编码？</p>
<ul>
<li>指明应用在实体内容上的编码格式，并保持实体信息原样压缩。客户端接收后解码</li>
</ul>
</li>
<li><p>什么是分块传输编码？</p>
<ul>
<li>在传输大容量数据的时候，通过把数据分割成多块，能够让浏览器逐步显示页面。这种把实体主体分块的功能成为分块传输编码</li>
<li>HTTP/1.1中存在一种称为传输编码的机制，它可以在通信的时候按某种编码方式传输，但只定义作用于分块传输编码中。</li>
</ul>
</li>
<li><p>如何发送多种数据的多部分对象集合？</p>
<ul>
<li>Content_type：multipart/form-data</li>
</ul>
</li>
<li><p>获取部分内容的范围请求？</p>
<ul>
<li>Range Request:制定下载的实体范围</li>
</ul>
</li>
</ol>
<h4 id="第四章-返回结果的HTTP状态码"><a href="#第四章-返回结果的HTTP状态码" class="headerlink" title="第四章 返回结果的HTTP状态码"></a>第四章 返回结果的HTTP状态码</h4><ol>
<li><p>响应的状态码的类别？</p>
<ul>
<li>1XX<ul>
<li>Informational(信息性状态码)：接收的请求正在处理</li>
</ul>
</li>
<li>2XX<ul>
<li>Success(成功状态码)：请求正常处理完毕</li>
</ul>
</li>
<li>3XX<ul>
<li>Redirection(重定向状态码)：需要进行附加操作以完成请求</li>
</ul>
</li>
<li>4XX<ul>
<li>Client Error(客户端错误状态码)：服务器无法处理请求</li>
</ul>
</li>
<li>5XX<ul>
<li>Server Error(服务器错误状态码)：服务器处理请求出错</li>
</ul>
</li>
</ul>
</li>
<li><p>2XX成功</p>
<ul>
<li>200 OK<ul>
<li>表示从客户端发来的请求在服务器端被正常处理了。</li>
</ul>
</li>
<li>204 No Content<ul>
<li>服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。</li>
</ul>
</li>
<li>206 Partial Content<ul>
<li>表示客户端进行了范围请求，而服务器成功执行了这部分的GET请求。响应报文中包含由Content-Range指定范围的实体内容</li>
</ul>
</li>
</ul>
</li>
<li><p>3XX重定向</p>
<ul>
<li>301 Moved Permanently<ul>
<li>永久性重定向。表示请求的资源已被分配了新的URI，以后赢使用资源现在所指的URI</li>
</ul>
</li>
<li>302 Found<ul>
<li>临时性重定向。表示请求的资源已被分配的新的URI，希望用户能使用新的URI访问。</li>
</ul>
</li>
<li>303 See Other<ul>
<li>由于请求对应的资源存在着另一个URI，应使用GET方法形象获取请求的资源</li>
</ul>
</li>
<li>304 Not Modified<ul>
<li>表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但因发生请求未满足条件的情况后，直接返回304。304返回的时候，不包含任何响应的主体部分，和重定向没关系</li>
</ul>
</li>
<li>307 Temporary Redirect<ul>
<li>临时重定向，和302类似，302标准禁止POST变换为GET，但实际使用的时候大家并不遵守。307会遵照浏览器标准，不会从POST编程GET。</li>
</ul>
</li>
</ul>
</li>
<li><p>4XX客户端错误</p>
<ul>
<li>400 Bad Request<ul>
<li>请求报文中存在语法错误。需修改请求的内容后再次发送请求</li>
</ul>
</li>
<li>401 Unauthorized<ul>
<li>发送的请求需要有通过HTTP认证(BASIC认证、DIGEST认证)的认证信息 </li>
</ul>
</li>
<li>403 Forbidden<ul>
<li>对请求资源的访问被服务器拒绝了。</li>
</ul>
</li>
<li>404 Not Found<ul>
<li>服务器上无法找到请求的资源。</li>
</ul>
</li>
</ul>
</li>
<li><p>5XX服务器错误 </p>
<ul>
<li>500 Internal Server Error<ul>
<li>服务器端在执行请求的时候发生了错误</li>
</ul>
</li>
<li>503 Service Unavailable<ul>
<li>服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。 </li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第五章-与HTTP协作的Web服务器"><a href="#第五章-与HTTP协作的Web服务器" class="headerlink" title="第五章 与HTTP协作的Web服务器"></a>第五章 与HTTP协作的Web服务器</h4><ol>
<li><p>用单台虚拟主机实现多个域名</p>
<ul>
<li>物理层面只有一台服务器，使用虚拟主机的功能，可以假想已具有多台服务器。</li>
<li>两个域名同时部署在同一个服务器上，使用DNS服务解析域名后，两者的访问IP地址相同。</li>
<li>在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的WEB网站，因此在发送HTTP请求的时候，必须在HOST首部内完整指定主机名或域名的URI</li>
</ul>
</li>
<li><p>什么是代理服务器？</p>
<ul>
<li>代理服务器的基本行为就是接受客户端发送的请求后转发给其他服务器。</li>
<li>代理不改变URI，会直接发送给前方持有资源的目标服务器。</li>
<li>可级联多台代理服务器，每次通过代理服务器转发请求或响应的时候，会追加写入Via首部信息</li>
</ul>
</li>
<li><p>代理的分类</p>
<ul>
<li>是否使用缓存：缓存代理会预先将资源的副本保存在代理服务器上，当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为相应返回。</li>
<li>是否会修改报文：不对报文做任何加工的代理类型成为透明代理，反之为非透明代理</li>
</ul>
</li>
</ol>
<h4 id="第六章-HTTP首部"><a href="#第六章-HTTP首部" class="headerlink" title="第六章 HTTP首部"></a>第六章 HTTP首部</h4><ol>
<li><p>HTTP首部字段类型？</p>
<ul>
<li>通用首部字段</li>
<li>请求首部字段</li>
<li>响应首部字段</li>
<li>实体首部字段</li>
</ul>
</li>
<li><p>通用首部字段</p>
<ul>
<li>Cache-Control：控制缓存行为</li>
<li>Connection：逐跳首部、连接的管理</li>
<li>Date：创建报文的日期时间</li>
<li>Pragma：报文指令  </li>
<li>Trailer：报文末端的首部一览</li>
<li>Transfer-Encoding：指定报文主体的编码方式</li>
<li>Upgrade：升级为其他协议</li>
<li>Via：代理服务器的相关信息</li>
<li>Warning：错误统治者</li>
</ul>
</li>
<li><p>请求首部字段：</p>
<ul>
<li>Accept：用户代理可处理的媒体类型</li>
<li>Accept-Charset：优先的字符集</li>
<li>Accept-Encoding：优先的内容编码</li>
<li>Accept-Language：优先的语言</li>
<li>Authorization：Web认证信息</li>
<li>Expect：期待服务器的特定行为</li>
<li>From：用户的电子邮箱地址</li>
<li>Host：请求资源所在的服务器</li>
<li>If-Match：比较实体标记</li>
<li>If-Modified-Since：比较资源的更新时机</li>
<li>If-None-Match：比较实体标记</li>
<li>If-Range：资源未更新时发送实体Byte的范围请求</li>
<li>If-Unmodified-Since：比较资源的更新时机</li>
<li>Max-Forwards：最大传输逐跳数</li>
<li>Proxy-Authorization：代理服务器要求客户端的认证信息</li>
<li>Range：实体的字节范围要求</li>
<li>Referer：对请求中URI的原始获取方</li>
<li>TE：传输编码的优先级</li>
<li>User-Agent：HTTP客户端程序的信息</li>
</ul>
</li>
<li><p>响应首部字段：</p>
<ul>
<li>Accept-Ranges：是否接受字节范围请求</li>
<li>Age：推算资源创建经过时间</li>
<li>ETag：资源的匹配信息</li>
<li>Location：令客户端重定向至指定URI</li>
<li>Proxy-Authenticate：代理服务器对客户端的认证信息</li>
<li>Retry-After：对再次发起请求的时机要求</li>
<li>Server：HTTP服务器的安装信息</li>
<li>Vary：代理服务器缓存的管理信息</li>
<li>WWW-Authenticate：服务器对客户端的认证信息</li>
</ul>
</li>
<li><p>实体首部字段：</p>
<ul>
<li>Allow：资源可支持的HTTP方法</li>
<li>Content-Encoding：实体主体使用的编码方式</li>
<li>Content-Language：实体主体的自然语言</li>
<li>Content-Length：实体主体的额大笑</li>
<li>Content-Location：替代对应资源的URI</li>
<li>Content-MD5：实体主体的报文摘要</li>
<li>Content-Range：实体主体的位置范围</li>
<li>Content-Type：实体主图的媒体类型</li>
<li>Expires：实体主体过期的日期时间</li>
<li>Last-Modified：资源的最后修改日期时间</li>
</ul>
</li>
<li><p>首部字段类型</p>
<ul>
<li>端到端首部：会转发给请求/响应对应的最终接受目标，且必须保存在由缓存生成的响应中，另外规定它必须被转发。</li>
<li>逐跳首部：只对单词转发有效，会因通过缓存或代理而不再转发</li>
</ul>
</li>
</ol>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/20/book-%E5%9B%BE%E8%A7%A3HTTP/" data-id="ck8e3fmsc00he27qy6n4q1f4o" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/book/" rel="tag">book</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li></ul>

    </footer>
  </div>
  
</article>


  
    <article id="post-pub-flutter-闲鱼" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/mLixin.github.io/2018/05/10/pub-flutter-%E9%97%B2%E9%B1%BC/" class="article-date">
  <time datetime="2018-05-10T09:23:05.000Z" itemprop="datePublished">2018-05-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/mLixin.github.io/categories/Flutter/">Flutter</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/mLixin.github.io/2018/05/10/pub-flutter-%E9%97%B2%E9%B1%BC/">Flutter学习笔记 - 闲鱼公众号</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h4 id="Android-Flutter内存初探"><a href="#Android-Flutter内存初探" class="headerlink" title="Android Flutter内存初探"></a><a href="https://mp.weixin.qq.com/s/efKCpCtvvHDHUiAsizobBQ" target="_blank" rel="noopener">Android Flutter内存初探</a></h4><p>主要关注Dart VM内存分配和回收相关的部分</p>
<ul>
<li><p>Dart的线程是不共享内存的，各自的堆和栈都是隔离的，彼此通过消息通道来通信。Dart天然不存在数据竞争和变量状态同步的问题，整个Flutter Framework Widget的渲染过程都运行在一个isolate中。</p>
</li>
<li><p>Dart VM将内存管理分为新生代和老年代</p>
<ul>
<li>新生代(New Generation)<ul>
<li>初次分配的对象的都位于新生代中，该区域主要存放内存较小并且生命周期较短的对象，比如局部变量。</li>
<li>新生代会频繁执行内存回收(GC)，回收采用“复制-清除”算法，将内存分为两块，运行时每次只使用其中一块，另一块备用，当发生GC的时候，当前内存使用的内存块中存活的对象拷贝到备用内存块中，然后清除当前使用内存块，最后交互两块内存的角色。</li>
</ul>
</li>
<li>老年代(Old Generation)<ul>
<li>新生代GC留下的对象会被转移到老年代中(这里可能还是和JVM一样会有年龄限制的，不是每次GC留下的对象都会马上转移到老年代中)。老年代存放生命力周期较长，内存较大的对象。</li>
<li>老年代GC采用<code>标记-清除</code>算法，分成标记和清除两个阶段。标记阶段，所有线程参与并发的完成对回收对象的标记，降低标记阶段耗时；清除阶段，由GC线程负责清理回收对象，和应用线程同时执行，不影响应用运行。</li>
</ul>
</li>
</ul>
</li>
<li><p>Android和Flutter加载图片使用的内存有什么区别？</p>
<ul>
<li>Android原生的ImageView在6.0和7.0版本使用的是Java虚拟机内存，而在Android8.0是使用的Native内存</li>
<li>Flutter中的Image Widget使用的内存是Graphics(图形缓冲区队列向屏幕显示像素所使用的内存，这是CPU共享的内存，不是CPU专用内存)，不懂，反正不是Java虚拟机内存，不会出现OOM</li>
</ul>
</li>
<li><p>Flutter和原生混合开发的是时候，有两种方案可以实现：</p>
<ul>
<li>一个Activity里面启动一个新的Flutter View</li>
<li>只用一个FlutterView，跳转的时候复用这个FlutterView<ul>
<li>Flutter Framework中FlutterView是绑定Activity使用的，必须attach一个Activity，为了避免Activity泄露，可以在detach的时候传入mainActivity，因为运行过程中mainActivity是会一直存在的。</li>
</ul>
</li>
</ul>
</li>
<li><p>复用FlutterView的时候会有问题，比如Activity切换的时候，就不得不将当前FlutterView detach掉给后面新建的Activity使用，会有空白闪动。</p>
</li>
<li><p>Flutter首帧渲染耗时较高，优化思路是，预先将要使用的FlutterView加载好首帧，这样在真正使用的时候就很快了。</p>
</li>
</ul>
<h4 id="深入了解Flutter界面开发"><a href="#深入了解Flutter界面开发" class="headerlink" title="深入了解Flutter界面开发"></a><a href="https://mp.weixin.qq.com/s/z2r2OmnY7r7dQrkO8ndkFQ" target="_blank" rel="noopener">深入了解Flutter界面开发</a></h4><ol>
<li><p>Flutter框架</p>
<ul>
<li>FrameWork<ul>
<li>Material/Cupertino</li>
<li>Widgets</li>
<li>Rendering</li>
<li>Animationg/Painting/Gestures</li>
<li>Foundation</li>
</ul>
</li>
<li>Engine<ul>
<li>Skia/Dart/Text</li>
</ul>
</li>
</ul>
</li>
<li><p>Rendering Pipeline</p>
<ul>
<li>GPU发出Vsync信号，会经过四个阶段到达Layer Tree<ul>
<li>Animate：Tick animations to change widget state</li>
<li>Build：Rebuild widgets to account for state changes</li>
<li>Layout：Update size and position of render objects</li>
<li>Paint：Record display lists for composited layers</li>
</ul>
</li>
</ul>
</li>
<li><p>三种视图树</p>
<ul>
<li>组合型：Composer角色，将其他widget进行拼装组合成一个新的widget<ul>
<li>StatelessWidgt</li>
<li>StatefuleWidget/State</li>
</ul>
</li>
<li>代理型：数据传递<ul>
<li>ProxyWidget</li>
</ul>
</li>
<li>展示型：具有实际展示内容的视图<ul>
<li>RenderObjectWidget</li>
<li>SingleChildRenderObjectWidget</li>
<li>LeafRenderObjectWidget</li>
<li>MultiChildRenderObjectWidget</li>
</ul>
</li>
</ul>
</li>
<li><p>创建树的过程</p>
<ul>
<li>创建Widget树</li>
<li>调用runApp(rootWidget)，将rootWidget传给rootElement，作为rootElement的子节点，生成Element树，再由Element树生成Render树<ul>
<li>Widget树：存放渲染内容、视图布局信息，widget的属性最好是immutable不变的。</li>
<li>Element树：存放上下文，通过Element遍历视图树，Element同时持有Widget和RenderObject</li>
<li>RenderObject树：根据Widget的布局属性进行layout，paint Widget传入的内容</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么widget都是immutable不可变的？</p>
<ul>
<li>flutter界面开发是一种响应式编程，主张simple is fast，flutter设计的初衷希望数据变更时发送通知到对应的可变更节点，由上到下重新create widget树进行刷新，思路简单，不用关心数据变更会影响到哪些节点。</li>
</ul>
</li>
<li><p>widget重新创建，element数和renderObject树是否也重新创建？</p>
<ul>
<li>不会，widget只是一个配置数据结构，创建非常轻量，官方对widget的创建和销毁做了优化，不用担心整个widget树重新创建所带来的性能问题，但是renderObject涉及到layout、paint等复杂操作，是一个真正渲染的view，整个view树重新创建开销就比较大</li>
</ul>
</li>
<li><p>树的更新规则</p>
<ol>
<li>找到widget对应的element节点，设置element为dirty，触发drawFrame，drawFrame会调用element的performRebuild()进行树重建</li>
<li>widget.build() == null，deactive element.child，删除子树，流程结束</li>
<li>element.child.widget == null，mount新子树，流程结束</li>
<li>element.child.widget == widget.build()，无需重建，否则进入流程5</li>
<li>widget.canUpdate(element.child.widget,newWidget) == true，更新child的slot，element.child.update(newWidget)(如果child还有子节点，则递归上面的流程进行子树更新),流程结束，否则转6</li>
<li>Widget.canUpdate(element.child.widget, newWidget) != true（widget的classtype 或者 key 不相等），deactivew element.child，mount新子树</li>
</ol>
</li>
<li><p>如何触发树的更新？</p>
<ul>
<li>全局更新：调用runApp(rootWidget)，flutter启动时候调用后不会再调用</li>
<li>局部子树更新：将该子树做StatefulWidget的一个子widget，并创建对应的State类实例，通过调用state.setState() 触发该子树的刷新</li>
</ul>
</li>
<li><p>StatefuleWidget和StatelessWidget的区别？</p>
<ul>
<li>StatelessWidget：<ul>
<li>无中间状态变化的widget，需要更新展示内容就得通过重新new，flutter推荐尽量使用StatelessWidget</li>
</ul>
</li>
<li>StatefulWidget：<ul>
<li>存在中间状态变化，引入state的类用于存放中间态，通过调用state.setState()进行此节点及以下的整个子树更新</li>
</ul>
</li>
</ul>
</li>
<li><p>State生命周期</p>
<ul>
<li>initState()<ul>
<li>state create之后被insert到tree的时候调用的</li>
</ul>
</li>
<li>didUpdateWidget(newWidget)<ul>
<li>祖先节点rebuild widget时调用</li>
</ul>
</li>
<li>deactivate()<ul>
<li>widget被remove的时候调用</li>
<li>一个widget从tree中remove掉，可以在dispose接口被调用前，重新instert到一个新tree中</li>
</ul>
</li>
<li>didChangeDependencies()<ul>
<li>初始化时，在initState()之后理科调用</li>
<li>当依赖的InheritedWidget rebuild会触发此接口被调用</li>
</ul>
</li>
<li>build()<ul>
<li>initState之后会被调用</li>
<li>didUpdateWidget之后被调用</li>
<li>setState之后</li>
<li>依赖的State对象改变之后</li>
<li>deactivate之后</li>
</ul>
</li>
<li>dispose()<ul>
<li>Widget彻底销毁时调用</li>
</ul>
</li>
<li>reassemble()<ul>
<li>hot reload调用</li>
</ul>
</li>
</ul>
</li>
<li><p>生命周期注意事项</p>
<ul>
<li>A页面push一个新的B页面，A页面的widget树中所有state会依次调用deactivate、didUpdateWidget、build</li>
<li>当ListView中的item滚动出可现实区域的时候，item会被从树中remove掉，此item子树中所有的state都会被dispose，state记录的数据都会销毁，item滚动回可显示区域时，会重新创建全新的state、element、renderobject</li>
<li>使用hot reload功能的时候，state实例没有重新创建，如果该state中存在一些复杂的资源更新需要重新加载才能生效，那么需要在reassemble()添加处理</li>
</ul>
</li>
</ol>
<h4 id="深入理解flutter的编译原理与优化"><a href="#深入理解flutter的编译原理与优化" class="headerlink" title="深入理解flutter的编译原理与优化"></a><a href="https://mp.weixin.qq.com/s/vlHt8jxbdzBqJZDobpsFVw" target="_blank" rel="noopener">深入理解flutter的编译原理与优化</a></h4><h4 id="深入理解Flutter引擎线程模式"><a href="#深入理解Flutter引擎线程模式" class="headerlink" title="深入理解Flutter引擎线程模式"></a><a href="https://mp.weixin.qq.com/s/hZ5PUvPpMlEYBAJggGnJsw" target="_blank" rel="noopener">深入理解Flutter引擎线程模式</a></h4><h4 id="Flutter-Plugin调用Native-APIs"><a href="#Flutter-Plugin调用Native-APIs" class="headerlink" title="Flutter Plugin调用Native APIs"></a><a href="https://mp.weixin.qq.com/s/WORru3f5rfABFMoxQ_2nYw" target="_blank" rel="noopener">Flutter Plugin调用Native APIs</a></h4><h4 id="Flutter混合工程改造实践"><a href="#Flutter混合工程改造实践" class="headerlink" title="Flutter混合工程改造实践"></a><a href="https://mp.weixin.qq.com/s/Q1z6Mal2pZbequxk5I5UYA" target="_blank" rel="noopener">Flutter混合工程改造实践</a></h4><h4 id="Release-Flutter的最后一公里"><a href="#Release-Flutter的最后一公里" class="headerlink" title="Release Flutter的最后一公里"></a><a href="https://mp.weixin.qq.com/s/xV-FGR9o2ODLFJFq4YwnKg" target="_blank" rel="noopener">Release Flutter的最后一公里</a></h4><h4 id="Flutter-React编程范式实践"><a href="#Flutter-React编程范式实践" class="headerlink" title="Flutter React编程范式实践"></a><a href="https://mp.weixin.qq.com/s/GRHvM0BHe2D9Qwb_nW0New" target="_blank" rel="noopener">Flutter React编程范式实践</a></h4><h4 id="闲鱼Fultter混合工程持续集成的最佳实践"><a href="#闲鱼Fultter混合工程持续集成的最佳实践" class="headerlink" title="闲鱼Fultter混合工程持续集成的最佳实践"></a><a href="https://mp.weixin.qq.com/s/5opwrgVr48e0YDYtEWFXZQ" target="_blank" rel="noopener">闲鱼Fultter混合工程持续集成的最佳实践</a></h4><h4 id="Flutter新锐专家之路：工程研发体系篇"><a href="#Flutter新锐专家之路：工程研发体系篇" class="headerlink" title="Flutter新锐专家之路：工程研发体系篇"></a><a href="https://mp.weixin.qq.com/s/YMnzLGrUdjd1PFlkZdFMqQ" target="_blank" rel="noopener">Flutter新锐专家之路：工程研发体系篇</a></h4><h4 id="Flutter新锐专家之路：混合开发篇"><a href="#Flutter新锐专家之路：混合开发篇" class="headerlink" title="Flutter新锐专家之路：混合开发篇"></a><a href="https://mp.weixin.qq.com/s/1AMvmuckg9bEODqhULVhPQ" target="_blank" rel="noopener">Flutter新锐专家之路：混合开发篇</a></h4><h4 id="万万没想到-Flutter这样外接纹理"><a href="#万万没想到-Flutter这样外接纹理" class="headerlink" title="万万没想到-Flutter这样外接纹理"></a><a href="https://mp.weixin.qq.com/s/KkCsBvnRayvpXdI35J3fnw" target="_blank" rel="noopener">万万没想到-Flutter这样外接纹理</a></h4><h4 id="深入理解Flutter-Platform-Channel"><a href="#深入理解Flutter-Platform-Channel" class="headerlink" title="深入理解Flutter Platform Channel"></a><a href="https://mp.weixin.qq.com/s/FT7UFbee1AtxmKt3iJgvyg" target="_blank" rel="noopener">深入理解Flutter Platform Channel</a></h4><h4 id="Flutter快速上车之Widget"><a href="#Flutter快速上车之Widget" class="headerlink" title="Flutter快速上车之Widget"></a><a href="https://mp.weixin.qq.com/s/kAWPj97w5NfiqAYEpi3zVA" target="_blank" rel="noopener">Flutter快速上车之Widget</a></h4><h4 id="Flutter之禅-内存优化篇"><a href="#Flutter之禅-内存优化篇" class="headerlink" title="Flutter之禅 内存优化篇"></a><a href="https://mp.weixin.qq.com/s/mHBz56OWKBB_g9YavVKTbQ" target="_blank" rel="noopener">Flutter之禅 内存优化篇</a></h4><h4 id="揭秘Flutter-Hot-Reload（基础篇）"><a href="#揭秘Flutter-Hot-Reload（基础篇）" class="headerlink" title="揭秘Flutter Hot Reload（基础篇）"></a><a href="https://mp.weixin.qq.com/s/Z9QPUJ3dZy2btBOlhSfyQw" target="_blank" rel="noopener">揭秘Flutter Hot Reload（基础篇）</a></h4><h4 id="Flutter瘦身大作战"><a href="#Flutter瘦身大作战" class="headerlink" title="Flutter瘦身大作战"></a><a href="https://mp.weixin.qq.com/s/IIoaY2uw6Bqzc9XWI91YFw" target="_blank" rel="noopener">Flutter瘦身大作战</a></h4><h4 id="Flutter中嵌入Native组件的正确姿势是…"><a href="#Flutter中嵌入Native组件的正确姿势是…" class="headerlink" title="Flutter中嵌入Native组件的正确姿势是…"></a><a href="https://mp.weixin.qq.com/s/JM_AB0vVH0uOY7v0ToDamw" target="_blank" rel="noopener">Flutter中嵌入Native组件的正确姿势是…</a></h4><h4 id="关于Flutter初始化，我必须告诉你的是…（干货）"><a href="#关于Flutter初始化，我必须告诉你的是…（干货）" class="headerlink" title="关于Flutter初始化，我必须告诉你的是…（干货）"></a><a href="https://mp.weixin.qq.com/s/5JYzHWmczimYy3QMlLUJ4w" target="_blank" rel="noopener">关于Flutter初始化，我必须告诉你的是…（干货）</a></h4><h4 id="做了2个多月的设计和编码，我梳理了Flutter动态化的方案对比及最佳实现"><a href="#做了2个多月的设计和编码，我梳理了Flutter动态化的方案对比及最佳实现" class="headerlink" title="做了2个多月的设计和编码，我梳理了Flutter动态化的方案对比及最佳实现"></a><a href="https://mp.weixin.qq.com/s/N5ih-DY5TuKyn_a0P2mz0Q" target="_blank" rel="noopener">做了2个多月的设计和编码，我梳理了Flutter动态化的方案对比及最佳实现</a></h4><h4 id="Flutter路由管理代码这么长长长长长，阿里工程师怎么高效解决？（实用）"><a href="#Flutter路由管理代码这么长长长长长，阿里工程师怎么高效解决？（实用）" class="headerlink" title="Flutter路由管理代码这么长长长长长，阿里工程师怎么高效解决？（实用）"></a><a href="https://mp.weixin.qq.com/s/YgE9lwEHb31WOWyraHL35w" target="_blank" rel="noopener">Flutter路由管理代码这么长长长长长，阿里工程师怎么高效解决？（实用）</a></h4><h4 id="Flutter-Exception降到万分之几的秘密"><a href="#Flutter-Exception降到万分之几的秘密" class="headerlink" title="Flutter Exception降到万分之几的秘密"></a><a href="https://mp.weixin.qq.com/s/JiJ3XwIq_ADM457M6CBSxA" target="_blank" rel="noopener">Flutter Exception降到万分之几的秘密</a></h4><h4 id="如何在Flutter上优雅地序列化一个对象（实用）"><a href="#如何在Flutter上优雅地序列化一个对象（实用）" class="headerlink" title="如何在Flutter上优雅地序列化一个对象（实用）"></a><a href="https://mp.weixin.qq.com/s/W5kQBe0vlnkG7VwIVAmnRA" target="_blank" rel="noopener">如何在Flutter上优雅地序列化一个对象（实用）</a></h4><h4 id="已开源-码上用它开始Flutter混合开发——FlutterBoost"><a href="#已开源-码上用它开始Flutter混合开发——FlutterBoost" class="headerlink" title="已开源|码上用它开始Flutter混合开发——FlutterBoost"></a><a href="https://mp.weixin.qq.com/s/v-wwruadJntX1n-YuMPC7g" target="_blank" rel="noopener">已开源|码上用它开始Flutter混合开发——FlutterBoost</a></h4><h4 id="打通前后端逻辑，客户端Flutter代码一天上线"><a href="#打通前后端逻辑，客户端Flutter代码一天上线" class="headerlink" title="打通前后端逻辑，客户端Flutter代码一天上线"></a><a href="https://mp.weixin.qq.com/s/hFdBtDQo1TvvxBGHLV3Stw" target="_blank" rel="noopener">打通前后端逻辑，客户端Flutter代码一天上线</a></h4><h4 id="燃烧我的卡路里——Flutter瘦内存、瘦包之图片渲染组件"><a href="#燃烧我的卡路里——Flutter瘦内存、瘦包之图片渲染组件" class="headerlink" title="燃烧我的卡路里——Flutter瘦内存、瘦包之图片渲染组件"></a><a href="https://mp.weixin.qq.com/s/QwNMm0P2z7RGJ_xzhto1RQ" target="_blank" rel="noopener">燃烧我的卡路里——Flutter瘦内存、瘦包之图片渲染组件</a></h4><h4 id="Fish-Redux中的Dispatch是怎么实现的？"><a href="#Fish-Redux中的Dispatch是怎么实现的？" class="headerlink" title="Fish Redux中的Dispatch是怎么实现的？"></a><a href="https://mp.weixin.qq.com/s/4hJzGPH8OQ6hkthRFuisBQ" target="_blank" rel="noopener">Fish Redux中的Dispatch是怎么实现的？</a></h4><h4 id="走近科学，探究阿里闲鱼团队通过数据提升Flutter体验的真相"><a href="#走近科学，探究阿里闲鱼团队通过数据提升Flutter体验的真相" class="headerlink" title="走近科学，探究阿里闲鱼团队通过数据提升Flutter体验的真相"></a><a href="https://mp.weixin.qq.com/s/26kY9rvRxVDkml2UeBnQfw" target="_blank" rel="noopener">走近科学，探究阿里闲鱼团队通过数据提升Flutter体验的真相</a></h4><h4 id="在闲鱼，我们如何用Dart做高效后端开发？"><a href="#在闲鱼，我们如何用Dart做高效后端开发？" class="headerlink" title="在闲鱼，我们如何用Dart做高效后端开发？"></a><a href="https://mp.weixin.qq.com/s/jAD3hacFMVcOv9GnAfCFOw" target="_blank" rel="noopener">在闲鱼，我们如何用Dart做高效后端开发？</a></h4><h4 id="Flutter高内聚组件怎么做？闲鱼闲鱼打造开源高效方案！"><a href="#Flutter高内聚组件怎么做？闲鱼闲鱼打造开源高效方案！" class="headerlink" title="Flutter高内聚组件怎么做？闲鱼闲鱼打造开源高效方案！"></a><a href="https://mp.weixin.qq.com/s/hw24XYmMDNj1iWZ2GAxMiQ" target="_blank" rel="noopener">Flutter高内聚组件怎么做？闲鱼闲鱼打造开源高效方案！</a></h4><h4 id="一个优秀的可定制化Flutter相册组件，看这一篇就够了"><a href="#一个优秀的可定制化Flutter相册组件，看这一篇就够了" class="headerlink" title="一个优秀的可定制化Flutter相册组件，看这一篇就够了"></a><a href="https://mp.weixin.qq.com/s/ARKAvDn52irJmyw5tEeD0w" target="_blank" rel="noopener">一个优秀的可定制化Flutter相册组件，看这一篇就够了</a></h4><h4 id="揭秘！一个高准确率的Flutter埋点框架如何设计"><a href="#揭秘！一个高准确率的Flutter埋点框架如何设计" class="headerlink" title="揭秘！一个高准确率的Flutter埋点框架如何设计"></a><a href="https://mp.weixin.qq.com/s/CMYi-f0-6nwZ4ZyV5K_lKA" target="_blank" rel="noopener">揭秘！一个高准确率的Flutter埋点框架如何设计</a></h4><h4 id="如何低成本实现Flutter富文本，看着一篇就够了！"><a href="#如何低成本实现Flutter富文本，看着一篇就够了！" class="headerlink" title="如何低成本实现Flutter富文本，看着一篇就够了！"></a><a href="https://mp.weixin.qq.com/s/CGMwDXQbv_YbwEzblwGqRQ" target="_blank" rel="noopener">如何低成本实现Flutter富文本，看着一篇就够了！</a></h4><h4 id="编程界的“二向箔”——Dart元编程"><a href="#编程界的“二向箔”——Dart元编程" class="headerlink" title="编程界的“二向箔”——Dart元编程"></a><a href="https://mp.weixin.qq.com/s/-vEha279U54piV8PGKDzbA" target="_blank" rel="noopener">编程界的“二向箔”——Dart元编程</a></h4>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2018/05/10/pub-flutter-%E9%97%B2%E9%B1%BC/" data-id="ck8e3fmsc00hf27qy3nwc846y" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/Flutter/" rel="tag">Flutter</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/mLixin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/mLixin.github.io/page/7/">&amp;laquo; Prev</a><a class="page-number" href="/mLixin.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/mLixin.github.io/page/6/">6</a><a class="page-number" href="/mLixin.github.io/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/mLixin.github.io/page/9/">9</a><a class="extend next" rel="next" href="/mLixin.github.io/page/9/">Next &amp;raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/Android/">Android</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/Dart/">Dart</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/Engineer/">Engineer</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/Flutter/">Flutter</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/Java/">Java</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/LeetCode/">LeetCode</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/%E5%85%A8%E6%A0%88/">全栈</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/">计算机基础</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></li><li class="category-list-item"><a class="category-list-link" href="/mLixin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/">设计模式</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/ART/" rel="tag">ART</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Algorithm/" rel="tag">Algorithm</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Android/" rel="tag">Android</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Android%E6%9C%BA%E5%88%B6/" rel="tag">Android机制</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Binder/" rel="tag">Binder</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Book/" rel="tag">Book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Dart/" rel="tag">Dart</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Engineer/" rel="tag">Engineer</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Flutter/" rel="tag">Flutter</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/GeekBang/" rel="tag">GeekBang</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Handler/" rel="tag">Handler</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Hybrid/" rel="tag">Hybrid</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Java/" rel="tag">Java</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/JsBridge/" rel="tag">JsBridge</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Launguage/" rel="tag">Launguage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/LeetCode/" rel="tag">LeetCode</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/LeetCode-Easy/" rel="tag">LeetCode-Easy</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/LeetCode-Hard/" rel="tag">LeetCode-Hard</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/LeetCode-Medium/" rel="tag">LeetCode-Medium</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/LeetCode-xxx/" rel="tag">LeetCode-xxx</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/NEED-COMPLETE/" rel="tag">NEED_COMPLETE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/NEED-MORE-ATTENTION/" rel="tag">NEED_MORE_ATTENTION</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Plan/" rel="tag">Plan</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/Pub/" rel="tag">Pub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/TODO/" rel="tag">TODO</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/View/" rel="tag">View</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/book/" rel="tag">book</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/pub/" rel="tag">pub</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/" rel="tag">事件传递</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E5%85%A8%E6%A0%88/" rel="tag">全栈</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" rel="tag">学习笔记</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" rel="tag">并发编程</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" rel="tag">数据结构与算法</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%A7%A3%E6%9E%90/" rel="tag">第三方库解析</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" rel="tag">网络协议</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" rel="tag">虚拟机</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" rel="tag">计算机基础</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/" rel="tag">设计模式之禅</a></li><li class="tag-list-item"><a class="tag-list-link" href="/mLixin.github.io/tags/%E8%AF%AD%E8%A8%80/" rel="tag">语言</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/mLixin.github.io/tags/ART/" style="font-size: 10px;">ART</a> <a href="/mLixin.github.io/tags/Algorithm/" style="font-size: 17.78px;">Algorithm</a> <a href="/mLixin.github.io/tags/Android/" style="font-size: 15.56px;">Android</a> <a href="/mLixin.github.io/tags/Android%E6%9C%BA%E5%88%B6/" style="font-size: 10px;">Android机制</a> <a href="/mLixin.github.io/tags/Binder/" style="font-size: 10px;">Binder</a> <a href="/mLixin.github.io/tags/Book/" style="font-size: 10px;">Book</a> <a href="/mLixin.github.io/tags/Dart/" style="font-size: 10px;">Dart</a> <a href="/mLixin.github.io/tags/Engineer/" style="font-size: 10px;">Engineer</a> <a href="/mLixin.github.io/tags/Flutter/" style="font-size: 12.22px;">Flutter</a> <a href="/mLixin.github.io/tags/GeekBang/" style="font-size: 10px;">GeekBang</a> <a href="/mLixin.github.io/tags/Handler/" style="font-size: 10px;">Handler</a> <a href="/mLixin.github.io/tags/Hybrid/" style="font-size: 10px;">Hybrid</a> <a href="/mLixin.github.io/tags/Java/" style="font-size: 20px;">Java</a> <a href="/mLixin.github.io/tags/JsBridge/" style="font-size: 10px;">JsBridge</a> <a href="/mLixin.github.io/tags/Launguage/" style="font-size: 10px;">Launguage</a> <a href="/mLixin.github.io/tags/LeetCode/" style="font-size: 18.89px;">LeetCode</a> <a href="/mLixin.github.io/tags/LeetCode-Easy/" style="font-size: 16.67px;">LeetCode-Easy</a> <a href="/mLixin.github.io/tags/LeetCode-Hard/" style="font-size: 12.22px;">LeetCode-Hard</a> <a href="/mLixin.github.io/tags/LeetCode-Medium/" style="font-size: 16.67px;">LeetCode-Medium</a> <a href="/mLixin.github.io/tags/LeetCode-xxx/" style="font-size: 13.33px;">LeetCode-xxx</a> <a href="/mLixin.github.io/tags/NEED-COMPLETE/" style="font-size: 10px;">NEED_COMPLETE</a> <a href="/mLixin.github.io/tags/NEED-MORE-ATTENTION/" style="font-size: 14.44px;">NEED_MORE_ATTENTION</a> <a href="/mLixin.github.io/tags/Plan/" style="font-size: 10px;">Plan</a> <a href="/mLixin.github.io/tags/Pub/" style="font-size: 10px;">Pub</a> <a href="/mLixin.github.io/tags/TODO/" style="font-size: 14.44px;">TODO</a> <a href="/mLixin.github.io/tags/View/" style="font-size: 10px;">View</a> <a href="/mLixin.github.io/tags/book/" style="font-size: 12.22px;">book</a> <a href="/mLixin.github.io/tags/pub/" style="font-size: 10px;">pub</a> <a href="/mLixin.github.io/tags/%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92/" style="font-size: 10px;">事件传递</a> <a href="/mLixin.github.io/tags/%E5%85%A8%E6%A0%88/" style="font-size: 10px;">全栈</a> <a href="/mLixin.github.io/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" style="font-size: 10px;">学习笔记</a> <a href="/mLixin.github.io/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/" style="font-size: 10px;">并发编程</a> <a href="/mLixin.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 10px;">数据结构与算法</a> <a href="/mLixin.github.io/tags/%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93%E8%A7%A3%E6%9E%90/" style="font-size: 10px;">第三方库解析</a> <a href="/mLixin.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/" style="font-size: 10px;">网络协议</a> <a href="/mLixin.github.io/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/" style="font-size: 10px;">虚拟机</a> <a href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" style="font-size: 11.11px;">计算机基础</a> <a href="/mLixin.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 11.11px;">计算机网络</a> <a href="/mLixin.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/" style="font-size: 10px;">设计模式之禅</a> <a href="/mLixin.github.io/tags/%E8%AF%AD%E8%A8%80/" style="font-size: 12.22px;">语言</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/12/">December 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/11/">November 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/10/">October 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/09/">September 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/08/">August 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/07/">July 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/06/">June 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/05/">May 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2019/01/">January 2019</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2018/09/">September 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2018/05/">May 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2017/08/">August 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/mLixin.github.io/archives/2017/07/">July 2017</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/mLixin.github.io/2019/12/09/java-list/">Java集合(一) 详解Java中的List接口</a>
          </li>
        
          <li>
            <a href="/mLixin.github.io/2019/11/27/dart-%E5%AE%98%E7%BD%91-Language-tour/">Dart-Launguage Tour</a>
          </li>
        
          <li>
            <a href="/mLixin.github.io/2019/11/26/leetcode-386/">LeetCode.386-Lexicographical Numbers</a>
          </li>
        
          <li>
            <a href="/mLixin.github.io/2019/11/26/leetcode-071/">LeetCode.071-Simplify Path</a>
          </li>
        
          <li>
            <a href="/mLixin.github.io/2019/11/22/leetcode-1116/">LeetCode.1116-xxx</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 mLiXin<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/mLixin.github.io/" class="mobile-nav-link">Home</a>
  
    <a href="/mLixin.github.io/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/mLixin.github.io/fancybox/jquery.fancybox.css">

  
<script src="/mLixin.github.io/fancybox/jquery.fancybox.pack.js"></script>




<script src="/mLixin.github.io/js/script.js"></script>




  </div>
</body>
</html>