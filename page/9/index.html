<!DOCTYPE html>
<html lang="zh-Hans">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/mLixin.github.io/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/mLixin.github.io/images/spiderman.ico">
  <link rel="icon" type="image/png" sizes="16x16" href="/mLixin.github.io/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/mLixin.github.io/images/logo.svg" color="#222">

<link rel="stylesheet" href="/mLixin.github.io/css/main.css">

<link rel="stylesheet" href="//fonts.googleapis.com/css?family=Monda:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext">
<link rel="stylesheet" href="/mLixin.github.io/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mlixin.com","root":"/mLixin.github.io/","scheme":"Mist","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false,"padding":18},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"save":"auto","color":"#222"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Be true to yourself.">
<meta property="og:type" content="website">
<meta property="og:title" content="mLiXin&#39;s Blog">
<meta property="og:url" content="http://mlixin.com/page/9/index.html">
<meta property="og:site_name" content="mLiXin&#39;s Blog">
<meta property="og:description" content="Be true to yourself.">
<meta property="article:author" content="mLiXin">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://mlixin.com/page/9/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-Hans'
  };
</script>

  <title>mLiXin's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta custom-logo">

    <a href="/mLixin.github.io/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">mLiXin's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">The truth conquers all.</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/mLixin.github.io/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/mLixin.github.io/archives/" rel="section"><i class="fa fa-fw fa-calendar"></i>时间线</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/mLixin.github.io/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/mLixin.github.io/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-leetcode">

    <a href="/mLixin.github.io/categories/LeetCode" rel="section"><i class="fa fa-fw fa-heartbeat"></i>LeetCode</a>

  </li>
        <li class="menu-item menu-item-tips">

    <a href="/mLixin.github.io/tips/" rel="section"><i class="fa fa-fw fa-heart"></i>说说</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/mLixin.github.io/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于我</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/07/08/android-component-activity/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/07/08/android-component-activity/" class="post-title-link" itemprop="url">Android 四大组件之Activity</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-07-08 15:51:22" itemprop="dateCreated datePublished" datetime="2019-07-08T15:51:22+08:00">2019-07-08</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><h5 id="源码调用流程图，基于api27"><a href="#源码调用流程图，基于api27" class="headerlink" title="源码调用流程图，基于api27"></a>源码调用流程图，基于api27</h5><p><img src="/images/android-activity-launch.jpg" alt="Android启动流程"></p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/07/08/android-component-activity/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/06/18/leetcode-004/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/06/18/leetcode-004/" class="post-title-link" itemprop="url">LeetCode.004-Median of Two Sorted Arrays</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-18 16:34:48" itemprop="dateCreated datePublished" datetime="2019-06-18T16:34:48+08:00">2019-06-18</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h6><ul>
<li>Source<ul>
<li><a href="https://leetcode.com/problems/median-of-two-sorted-arrays/submissions/" target="_blank" rel="noopener">4.Median of Two Sorted Arrays</a> </li>
</ul>
</li>
<li>Title<ul>
<li>Median of Two Sorted Arrays</li>
</ul>
</li>
<li>Content<ul>
<li>There are two sorted arrays nums1 and nums2 of size m and n respectively.Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).You may assume nums1 and nums2 cannot be both empty.</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/06/18/leetcode-004/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/06/17/leetcode-003/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/06/17/leetcode-003/" class="post-title-link" itemprop="url">LeetCode.003-Longest Substring Without Repeating Characters</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-17 17:59:05" itemprop="dateCreated datePublished" datetime="2019-06-17T17:59:05+08:00">2019-06-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h6><ul>
<li>Source<ul>
<li><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">3. Longest Substring Without Repeating Characters</a> </li>
</ul>
</li>
<li>Title<ul>
<li>Longest Substring Without Repeating Characters</li>
</ul>
</li>
<li>Content<ul>
<li>Given a string, find the length of the longest substring without repeating characters.</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/06/17/leetcode-003/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/06/17/leetcode-002/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/06/17/leetcode-002/" class="post-title-link" itemprop="url">LeetCode.002-Add Two Numbers</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-17 16:40:27" itemprop="dateCreated datePublished" datetime="2019-06-17T16:40:27+08:00">2019-06-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h6><ul>
<li>Source<ul>
<li><a href="https://leetcode.com/problems/add-two-numbers/submissions/" target="_blank" rel="noopener">2.Add Two Numbers</a></li>
</ul>
</li>
<li>Title    <ul>
<li>Add Two Numbers</li>
</ul>
</li>
<li>Content<ul>
<li>You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.You may assume the two numbers do not contain any leading zero, except the number 0 itself.</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/06/17/leetcode-002/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/06/17/leetcode-001/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/06/17/leetcode-001/" class="post-title-link" itemprop="url">LeetCode.001-Two Sum</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-06-17 16:19:03" itemprop="dateCreated datePublished" datetime="2019-06-17T16:19:03+08:00">2019-06-17</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/LeetCode/" itemprop="url" rel="index"><span itemprop="name">LeetCode</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h6 id="Question"><a href="#Question" class="headerlink" title="Question"></a>Question</h6><ul>
<li>Source<ul>
<li><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">1.Two Sum</a></li>
</ul>
</li>
<li>Title<ul>
<li>Two Sum</li>
</ul>
</li>
<li>Content<ul>
<li>Given an array of integers, return indices of the two numbers such that they add up to a specific target.You may assume that each input would have exactly one solution, and you may not use the same element twice.</li>
</ul>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/06/17/leetcode-001/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/05/24/android-jsbridge/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/05/24/android-jsbridge/" class="post-title-link" itemprop="url">Android JsBridge的原理与实现</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-24 18:06:36" itemprop="dateCreated datePublished" datetime="2019-05-24T18:06:36+08:00">2019-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h5 id="Native调用Js"><a href="#Native调用Js" class="headerlink" title="Native调用Js"></a>Native调用Js</h5><ul>
<li><p>api19之前</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">public void loadUrl(String url)</span><br></pre></td></tr></table></figure>
</li>
<li><p>api19及之后（效率更高）</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line">    * Compatibility note. Applications targeting &#123;@link android.os.Build.VERSION_CODES#N&#125; or</span><br><span class="line">    * later, JavaScript state from an empty WebView is no longer persisted across navigations like</span><br><span class="line">    * &#123;@link #loadUrl(String)&#125;. For example, global variables and functions defined before calling</span><br><span class="line">    * &#123;@link #loadUrl(String)&#125; will not exist in the loaded page. Applications should use</span><br><span class="line">    * &#123;@link #addJavascriptInterface&#125; instead to persist JavaScript objects across navigations.</span><br><span class="line">    *&#x2F;</span><br><span class="line">public void evaluateJavascript(String script, ValueCallback&lt;String&gt; resultCallback)</span><br></pre></td></tr></table></figure>
<p>  不同于上面的<code>loadUrl</code>，执行完以后就结束了，这种方法可以在执行完以后立即拿到Js返回的结果，但是这个方法有兼容性的要求，所以在<code>minSDK&lt;19</code>的app上，一般还是用的<code>loadUrl</code>。</p>
</li>
</ul>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/05/24/android-jsbridge/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/05/09/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ART/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/05/09/book-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ART/" class="post-title-link" itemprop="url">深入理解Android:Java虚拟机ART 学习笔记</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-05-09 14:39:43" itemprop="dateCreated datePublished" datetime="2019-05-09T14:39:43+08:00">2019-05-09</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/Android/" itemprop="url" rel="index"><span itemprop="name">Android</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>暂时大概了解，深入太难，等我哪天C++写溜了再来。Done for now.</p>
<h4 id="第2章-深入理解Class文件格式"><a href="#第2章-深入理解Class文件格式" class="headerlink" title="第2章 深入理解Class文件格式"></a>第2章 深入理解Class文件格式</h4><ol start="0">
<li><p>扩展阅读</p>
<ul>
<li><a href="https://docs.oracle.com/javase/specs/jvms/se7/html/index.html" target="_blank" rel="noopener">Java vm官方规范</a><ul>
<li>Class文件格式在第4章</li>
<li>Java指令码的内容在第6、7章</li>
</ul>
</li>
</ul>
</li>
<li><p>Class文件是什么？</p>
<ul>
<li>Java源代码经Java编译器编译后得到的Java字节码文件，可以看做是Java虚拟机的可执行文件。</li>
</ul>
</li>
<li><p>Class文件</p>
<ol>
<li>u4:magic<ul>
<li>取值必须是0xCAFEBABE</li>
</ul>
</li>
<li>u2:minor_version<ul>
<li>class文件版本的小版本信息</li>
</ul>
</li>
<li>u2:major_version<ul>
<li>class文件版本的大版本信息</li>
</ul>
</li>
<li>u2:constant_pool_count<ul>
<li>常量池数组中元素的个数</li>
</ul>
</li>
<li>cp_info:constant_pool[constant_pool_count-1]<ul>
<li>大小为constant_pool_count决定，是一个存储cp_info信息的数组。每个Class文件都包含一个常量池。常量池在代码中对应为一个数组，数组元素类型就是cp_info。注意数组索引从1开始。</li>
</ul>
</li>
<li>u2:access_flags<ul>
<li>表明该类的访问权限，public、private之类</li>
</ul>
</li>
<li>u2:this_class<ul>
<li>存储的是指向常量池数组元素的索引，通过这个索引和常量池对应元素的内容，可以知道本类的类名(只是类名，不包含包名，类名最终用字符串描述)</li>
</ul>
</li>
<li>u2:super_class<ul>
<li>存储的是指向常量池数组元素的索引，通过这个索引和常量池对应元素的内容，可以知道父类的类名(只是类名，不包含包名，类名最终用字符串描述)</li>
</ul>
</li>
<li>u2:interfaces_count<ul>
<li>存储的是指向常量池数组里的索引，通过这个索引可以知道该类实现了多少个接口</li>
</ul>
</li>
<li>u2:interface[interfaces_count]<ul>
<li>存储的是指向常量池数组里的索引，通过这个索引可以知道接口类的类名</li>
</ul>
</li>
<li>u2:fields_count<ul>
<li>成员变量的数量</li>
</ul>
</li>
<li>field_info:fields[fields_count]<ul>
<li>成员变量的信息</li>
</ul>
</li>
<li>u2:methods_count<ul>
<li>成员函数的数量</li>
</ul>
</li>
<li>method_info:methods[methods_count]<ul>
<li>成员函数的信息</li>
</ul>
</li>
<li>u2:attributes_count<ul>
<li>属性信息数量</li>
</ul>
</li>
<li>attribute_info:attributes[attributes_Count]<ul>
<li>属性信息(调试信息就记录了某局代码对应源文件哪一行、函数对应的Java字节码也属于属性信息的一种。另外源文件中的注解也属于属性。)</li>
</ul>
</li>
</ol>
</li>
<li><p>常量池及相关内容</p>
<ul>
<li>常量池对应的就是一个类型为cp_info的数组，每一个cp_info存储了一个常量项，每一个常量项的第一个字节用于表明常量项的类型，后面才是具体的常量项内容。<ul>
<li>具体常量类型可见章节底部表格。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么要单独分一个CONSTANT_UTF8类型出来存储字符串？</p>
<ul>
<li>CONSTANT_Class/Fieldref/String/Method/Methodref等等最后包含的内容都是字符串，这样可以节省Class文件的空间。</li>
<li>Android的dex文件在 Class文件基础上做了进一步的优化以节省空间。</li>
</ul>
</li>
<li><p>如何用字符串来描述成员变量、成员函数？</p>
<ul>
<li>数据类型的描述规则<ul>
<li>原始数据类型B/C/D/F/I/J/S/Z分别对应byte/char/double/float/int/long/short/boolean</li>
<li>引用数据类型<code>LClassName</code>(ClassName为对应类的全路径名 ),如<code>Ljava/lang/String</code>，表示String类型</li>
<li>数组也是引用类型，用<code>[其他类型的描述名</code>来表示，如int数组表示为<code>[I</code>,字符串数组表示为<code>[java/lang/String</code>，二维数组表示为<code>[[I</code></li>
</ul>
</li>
<li>成员变量的描述规则(Field Descriptor)<ul>
<li>FieldDescriptor：只包含FieldType一种信息</li>
<li>FieldType：<ul>
<li>BaseType：B|C|D|F|I|J|S|Z</li>
<li>ObjectType: L ClassName</li>
<li>ArrayType:[ ComponentType(ComponentType由上面的FieldType构成)</li>
</ul>
</li>
</ul>
</li>
<li>成员函数的描述规则(Method Descriptor)<ul>
<li>MethodDescriptor的描述需要包含返回值及参数的数据类型</li>
<li>MethodDescriptor</li>
<li>ParamterDescriptor：FieldType</li>
<li>ReturnDescriptor：Field|VoidDescriptor</li>
<li>举例<ul>
<li><code>System.out.println(String str)</code>对应Method Descriptor为<code>(Ljava/lang/String；)V</code></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>acess_flags介绍</p>
<ul>
<li>Class的特殊access_flags取值<ul>
<li>ACC_SUPER：用于invokespecial指令</li>
<li>ACC_SYNTHETIC：表明该类由编译器根据情况生成，源码里无法显示定义这样的类。</li>
</ul>
</li>
<li>Field的access_flag取值<ul>
<li>ACC_TRANSIENT：说明该成员不能被串行化</li>
<li>ACC_SYNTHETIC：说明该成员由编译器根据情况生成的，源码里无法显示定义这样的成员</li>
</ul>
</li>
<li>Method的access_flag<ul>
<li>ACC_SYNCHRONIZED：synchronized函数</li>
<li>ACC_BRIDGE：桥接方法，由编译器根据情况生成</li>
<li>ACC_VARARGS：可变参数个数的函数</li>
<li>ACC_STRICT：strictfp函数(strict float point,精确浮点)</li>
<li>ACC_SYNTHETIC：表明该成员由编译器根据情况生成的，源码里无法直接定义这样的成员。</li>
</ul>
</li>
</ul>
</li>
<li><p>属性包括哪些？</p>
<ul>
<li>attribute_name_index:属性名称，指向常量池UTF8常量项的索引<ul>
<li>ConstantValue：fieldInfo中出现，描述一个常量成员域</li>
<li>Code：methodInfo中出现，用于描述一个函数的内容，即源码中该函数内容编译后得到的虚拟机指令</li>
<li>Exceptions：一个函数抛出异常或错误，methodInfo中会有此属性</li>
<li>SourceFile：包含一个指向utf8常量项的树荫，包含此Class对应的源码文件名</li>
<li>LocalVariableTable：属性还可以包含属性，改属性就是包含在Code属性中的，用来描述一个函数的本地变量相关信息，比如这个变量的名字，这个变量在源码哪一行定义的。</li>
</ul>
</li>
<li>attribute_length：该属性具体内容的长度，即下面info数组的长度</li>
<li>info[attribute_length]：属性具体内容</li>
</ul>
</li>
<li><p>code属性都包括哪些内容？</p>
<ul>
<li>函数的内容(这个函数的源码转换后得到的Java字节码)就存储在Code属性中。</li>
<li>主要包括：<ul>
<li>attribute_name_index：指向内容为”code”的utf8_info常量项</li>
<li>max_stack、max_locals：JVM执行指令的时候，操作数存储在操作数栈中，没一个操作数占用一个或者两个栈顶。max_stack说明这个函数在执行过程中，需要最深多少栈空间。max_locals表示该函数包括最多几个局部变量</li>
<li>code_length和code：函数对应的指令内容也就是这个函数的源码经过编译器转换后得到的Java指令码存储在code数组中，长度由code_length表明</li>
<li>exception_table_length和exception_table：一个函数可以包含多个try/catch语句，一个try/catch语句对应exception_table数组中的一项。<ul>
<li>包括stact_pc、end_pc、handler_pc、cache_type</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>LineNumberTable属性包括哪些内容？</p>
<ul>
<li>用于Java的调试，可指明某条指令对应于源码哪一行。</li>
<li>主要包括：<ul>
<li>start_pc：指向Code_attribute中code数组某处指令</li>
<li>line_number：说明start_pc位于源码的哪一行</li>
</ul>
</li>
</ul>
</li>
<li><p>LocalVariableTable属性包括哪些内容？</p>
<ul>
<li>用于描述一个函数具备变量相关的信息</li>
<li>主要包括：<ul>
<li>start_pc和length：局部变量在code数组中的有效范围</li>
<li>name_index：局部变量的名字</li>
<li>descriptor_index：局部变量的类型</li>
</ul>
</li>
</ul>
</li>
<li><p>Java指令码介绍(了解即可)</p>
<ul>
<li>Java指令码长度为一个字节，指令码后面跟0或多个参数<ul>
<li>JVM规范第6章：介绍每个指令码的格式、所带参数、功能及使用场景</li>
<li>JVM规范第7张：指令码的取值和对应的助记符</li>
</ul>
</li>
<li>指令码<ul>
<li>invokevirtual指令</li>
<li>dup_x1指令：栈顶v1、v2，使用这个指令以后，编程栈顶v1、v2、v1 </li>
</ul>
</li>
</ul>
</li>
</ol>
<table>
<thead>
<tr>
<th>常量项类型</th>
<th>tag取值</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CONSTANT_Class</td>
<td>7</td>
<td>代表类或接口的信息</td>
</tr>
<tr>
<td>CONSTANT_Fieldref</td>
<td>9</td>
<td>成员变量信息，包括所属类的类名、变量和函数名、函数参数、返回值类型等。</td>
</tr>
<tr>
<td>CONSTANT_Methodref</td>
<td>10</td>
<td>成员函数信息，包括所属类的类名、变量和函数名、函数参数、返回值类型等。</td>
</tr>
<tr>
<td>CONSTANT_InterfaceMethodref</td>
<td>11</td>
<td>接口函数信息，包括所属类的类名、变量和函数名、函数参数、返回值类型等。</td>
</tr>
<tr>
<td>CONSTANT_String</td>
<td>8</td>
<td>代表一个字符串，本身不存储字符串的内容，只存储一个索引值</td>
</tr>
<tr>
<td>CONSTANT_Integer</td>
<td>3</td>
<td>4个字节，int型数据的信息</td>
</tr>
<tr>
<td>CONSTANT_Float</td>
<td>4</td>
<td>4个字节，float型数据的信息</td>
</tr>
<tr>
<td>CONSTANT_Long</td>
<td>5</td>
<td>8个字节，long型数据的信息</td>
</tr>
<tr>
<td>CONSTANT_Double</td>
<td>6</td>
<td>8个字节，double型数据的信息</td>
</tr>
<tr>
<td>CONSTANT_NameAndType</td>
<td>12</td>
<td>描述类的成员域或成员函数相关的信息</td>
</tr>
<tr>
<td>CONSTANT_Utf8</td>
<td>1</td>
<td>存储字符串的常量项，真正包含了字符串的内容。CONSTANT_String只存储了一个指向这里的索引</td>
</tr>
<tr>
<td>CONSTANT_MethodHandle</td>
<td>15</td>
<td>描述MethodHandle信息，MethodHandle和反射有关系</td>
</tr>
<tr>
<td>CONSTANT_MethodType</td>
<td>16</td>
<td>描述一个成员函数的信息，只包括函数的参数类型和返回值类型，不包含函数名和所属类的类名</td>
</tr>
<tr>
<td>CONSTANT_InvokeDynamic</td>
<td>18</td>
<td>用于invokeDynamic指令。invokeDynamic和Java平台上实现了一些动态语言相类似的有关功能</td>
</tr>
</tbody></table>
<h4 id="第3章-深入理解Dex文件格式"><a href="#第3章-深入理解Dex文件格式" class="headerlink" title="第3章 深入理解Dex文件格式"></a>第3章 深入理解Dex文件格式</h4><ol>
<li><p>为什么不直接使用Class文件，而用Dex？</p>
<ul>
<li>Dex核心内容和Class文件类似，可以和Class文件相互转化，但是Android虚拟机只能识别Dex文件</li>
<li>移动设备内存、存储空间小，主要使用ARM的CPU，通用寄存器较多。</li>
</ul>
</li>
<li><p>Dex和Class文件格式的区别？</p>
<ul>
<li>字节码文件的创建<ul>
<li>一个Class文件对应一个Java源码文件，而一个Dex文件可对应多个Java源码文件。</li>
<li>Android里面的Java源文件会先编译成多个.class文件，然后再合并到classes.dex文件中<ul>
<li>class文件之间存在重复字符串等信息，而classes.dex由于包含了多个Class文件的内容，可以进一步去除其中的重复信息。</li>
<li>如果一个class文件依赖另一个class文件，则虚拟机处理的时候，需要读取另外一个class文件的内容，这可能导致CPU和存储设备进行更多的I/O操作，而classes.dex由于一个文件就包含了所有的信息，相对而言会减少I/O操作的次数</li>
</ul>
</li>
</ul>
</li>
<li>字节序<ul>
<li>Java平台字节序是Big Endian，所以class文件也是采用的Big Endian字节序来组织内容的。而Android平台上的Dex文件默认的字节序是Little Endian<ul>
<li>大端字节序（big endian）：高位字节在前，低位字节在后，这是人类读写数值的方法。</li>
<li>小端字节序（little endian）：低位字节在前，高位字节在后，即以0x1122形式储存。</li>
</ul>
</li>
</ul>
</li>
<li>新增LEB128数据类型<ul>
<li>Dex文件定义了一种名为LEB128的数据类型(Little Endian Based 128),唯一的功能就是用于表示32位比特位长度的数据。</li>
</ul>
</li>
<li>信息描述规则<ul>
<li>数据类型描述没有区别 </li>
<li>简短描述<ul>
<li>Dex文件格式中，简短描述用来描述函数的参数和返回值信息，类似Class文件格式的MEthodDescriptor，不过省略了很多字符。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>Dex文件都包括哪些内容？</p>
<ul>
<li>概括来说：header_item(header)、string_ids、type_ids(类型相关)、proto_ids、field_ids(成员变量)、method_ids(成员函数)、class_defs(类的信息)、data(重要的数据内容)、link_data(预留区域)</li>
<li>header_item<ul>
<li>Dex文件头结构的类型，主要包括<ul>
<li>magic：取值固定</li>
<li>checksum：文件内容的校验和，不包括magic和自己，用于检查文件是否损坏</li>
<li>signature：签名信息，不包括magic、checksum和自己，用于检查文件是否被篡改</li>
<li>file_size：整个文件的长度</li>
<li>header_size：默认是0x70个字节</li>
<li>endian_tag：表示文件内容应该按什么字节序来处理，默认Little Endian</li>
</ul>
</li>
</ul>
</li>
<li>xxx_id_item(xxx_ids)<ul>
<li>string_id_item</li>
<li>type_id_item</li>
<li>proto_id_item</li>
<li>field_id_item</li>
<li>method_id_item</li>
</ul>
</li>
<li>class_def</li>
<li>code_item </li>
</ul>
</li>
<li><p>Dex指令码和Java指令码的区别？</p>
<ul>
<li>Dex文件中存储函数内容的insns数组比Class文件中存储函数内容的code数组解析起来要有难度。<ul>
<li>Andorid虚拟机在执行指令码的时候不需要操作数栈，所有参数要么和Class指令码一样直接跟在指令码后面，要么就存储在寄存器中。这样指令码就需要携带一些信息来表示该指令执行的时候需要操作哪些寄存器。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第4章-深入理解ELF文件格式"><a href="#第4章-深入理解ELF文件格式" class="headerlink" title="第4章 深入理解ELF文件格式"></a>第4章 深入理解ELF文件格式</h4><ol start="0">
<li>了解即可，应用层面不用理解太多。</li>
<li>Java虚拟机的可执行文件是.class文件，Dalvik虚拟机的可执行文件是.dex文件，而ART虚拟机的可执行文件是.oat文件</li>
<li>.oat是一种定制化的ELF文件，所以ELF文件是oat文件的基础。</li>
<li>ELF文件的两个特性？<ul>
<li>Executable：可执行。ELF文件将参与程序的执行工作。包括二进制程序的运行以及动态库.so文件的加载</li>
<li>Linkable：可链接。ELF文件是编译链接工作的重要参与者</li>
</ul>
</li>
<li>ELF文件包括哪些内容？<ul>
<li>头结构</li>
<li>Linking View：链接视图，从编译链接的角度来观察一个ELF文件应该包含哪些内容</li>
<li>Execution View：执行视图，从执行的角度来观察一个ELF文件应该包含什么信息</li>
</ul>
</li>
</ol>
<h4 id="第14章-ART中的GC"><a href="#第14章-ART中的GC" class="headerlink" title="第14章 ART中的GC"></a>第14章 ART中的GC</h4><ol>
<li><p>Mark-Sweep Collection原理</p>
<ul>
<li>Mark阶段：搜索内存中的Java对象(对ART虚拟机而言，就是从root set遍历Object对象)，对那些能搜到的对象进行标记</li>
<li>Sweep阶段：释放那些没有被标记的对象所占据的内存。</li>
</ul>
</li>
<li><p>Copying Collection原理</p>
<ul>
<li>将堆分为大小相同的两个空间，fromspace、tospace。对象的内存分配只使用tospace</li>
<li>tospace空间不够用的时候将触发GC。GC的第一个工作就是将指向这两个空间的变量进行互换</li>
<li>从root set开始遍历，将遍历过程中访问到的对象从fromspace拷贝到tospace中。</li>
<li>当fromspace中活对象全部拷贝完后，该空间的内存就可以整体释放。</li>
<li>tips：还有另外一种Copying的实现方式，是分了三块内存去处理</li>
</ul>
</li>
<li><p>Mark-Compact Collection原理</p>
<ul>
<li>Mark阶段，从root set触发遍历对象以标记存活的对象，没有被标记的则认为是垃圾对象</li>
<li>压缩阶段，将存活对象挪到一起去。</li>
</ul>
</li>
<li><p>其他的重要概念</p>
<ul>
<li>mutator和collector<ul>
<li>collector表示内存回收相关的功能模块，mutator代表应用程序中除collector之外的其他部分</li>
</ul>
</li>
<li>Incremental Collection(增量回收)<ul>
<li>分代GC是增量回收的一种实现方式，heap被划分为新生代、老年代等部分，而GC往往只针对其中某一代，符合增量式回收的定义。</li>
<li>早期GC实现中，垃圾回收会扫描全部的堆内存，需要暂停所有其他非GC线程的运行才能执行一次GC，对程序运行的影响非常大，而增量式回收可以每次只针对heap的一部分做GC，从而大幅度减少停顿时间。</li>
</ul>
</li>
<li>Parallel Collection(并行回收)<ul>
<li>程序中有多个垃圾回收线程，它们可以同时执行回收工作中的某些任务。比如Mark-Sweep算法而言，可以使用多个线程来做标记工作。</li>
</ul>
</li>
<li>Concurrent Collection(并发回收)<ul>
<li>程序中垃圾回收线程虽然只有一个，但是在回收工作的某个阶段，回收线程可以和其他非回收线程(mutator)同时运行，这样对程序运行的影响更小。相反，不适用concurrent collection的话，回收线程在工作的时候可能就需要暂停mutator线程的执行，也就是stop-the-world的情况，对程序影响较大。</li>
</ul>
</li>
</ul>
</li>
<li><p>通过Runtime VisitRoots函数可知，root set包含的内容大致可从下面几个方面获取？(不是通过其他Object对象的引用型成员来找到的，而只能由虚拟机根据其实现的特点来确定)</p>
<ul>
<li>每一个Thread对象的VisitRoots函数</li>
<li>JavaVmExt的VisitRoots</li>
<li>Runtime成员变量sentinel、pre_allocated_OutOfMemoryError_和pre_allocated_NoClassDefFoundError_。这三个变量代表Java层的三个对象，由虚拟机直接持有，所以它们对应的root类型为kRootVMInternal</li>
<li>RegTypeCache VisitStaticRoots函数</li>
<li>InternTable VisitRoots函数</li>
<li>ClassLinker VisitRoots函数</li>
<li>Runtime VisitConstantRoots函数</li>
</ul>
</li>
</ol>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/" class="post-title-link" itemprop="url">Geek Android开发高手课 学习笔记</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2019-01-03 09:37:13" itemprop="dateCreated datePublished" datetime="2019-01-03T09:37:13+08:00">2019-01-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h4><p>一遍不行就两遍，看不懂就死磕，一直看不懂就一直死磕。</p>
          <!--noindex-->
            <div class="post-button">
              <a class="btn" href="/mLixin.github.io/2019/01/03/GeekBang-Android%E5%BC%80%E5%8F%91%E9%AB%98%E6%89%8B%E8%AF%BE/#more" rel="contents">
                阅读全文 &raquo;
              </a>
            </div>
          <!--/noindex-->
        
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2018/09/28/book-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2018/09/28/book-%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%A6%85/" class="post-title-link" itemprop="url">设计模式之禅 学习笔记</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-28 10:29:33" itemprop="dateCreated datePublished" datetime="2018-09-28T10:29:33+08:00">2018-09-28</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" itemprop="url" rel="index"><span itemprop="name">设计模式</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="第1、2、3、4、5、6章-六大设计原则"><a href="#第1、2、3、4、5、6章-六大设计原则" class="headerlink" title="第1、2、3、4、5、6章 六大设计原则"></a>第1、2、3、4、5、6章 六大设计原则</h4><ol>
<li><p>6大设计原则都是什么？</p>
<ul>
<li>单一职责原则</li>
<li>里氏替换原则</li>
<li>依赖倒置原则</li>
<li>接口隔离原则</li>
<li>迪米特原则</li>
<li>开闭原则</li>
</ul>
</li>
<li><p>什么是单一职责原则(Single Responsibility Principle)？</p>
<ul>
<li>应该有且仅有一个原因引起类的变更。(There should never be more than one reason for a class to change.)</li>
</ul>
</li>
<li><p>什么是里氏替换原则(Liskov Substitution Principle)？</p>
<ul>
<li>所有引用基类的地方必须能透明地使用其子类的对象，(Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.).即只要父类能出现的地方，子类就可以出现，而且替换为子类也不会产生任何错误或异常，使用者可能根本不序言知道是父类还是子类，但是反过来就不行了，有子类出现的地方，父类未必就能适应。</li>
<li>4层含义：<ul>
<li>子类必须完全实现父类的方法</li>
<li>子类可以有自己的个性</li>
<li>覆盖或实现父类的方法时输入参数可以被放大</li>
<li>覆写或实现父类的方法时输出结果可以被缩小</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是依赖倒置原则(Dependence Inversion Principle)？</p>
<ul>
<li>高层模块不应该依赖底层模块，两者都应该依赖其抽象；抽象不应该依赖细节；细节应该依赖抽象。(High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.)</li>
</ul>
</li>
<li><p>什么是接口隔离原则(Interface Segregation Principle)？</p>
<ul>
<li>建立单一接口，不要建立臃肿庞大的接口。就是接口尽量细化，同时接口中的方法尽量少。</li>
<li>4层含义：<ul>
<li>接口要尽量小</li>
<li>接口要高内聚</li>
<li>定制服务</li>
<li>接口设计是有限度的。</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是迪米特原则(Law of Demeter)？</p>
<ul>
<li>一个对象应该对其他对象有最少的了解。就是一个类应该对自己需要耦合或调用的类知道得最少。</li>
<li>四层含义：<ul>
<li>只和朋友交流</li>
<li>朋友间也是有距离的</li>
<li>是自己的就是自己的：如果一个方法放在本类中既不增加类间关系，也对本类不产生负面影响，那就放置在本类中</li>
<li>谨慎使用Serializable</li>
</ul>
</li>
</ul>
</li>
<li><p>什么是开闭原则(Open Closed Principle)？</p>
<ul>
<li>一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。(Soft entities like classes,modules and funtions should be open for extension but closed for modifycations.)</li>
</ul>
</li>
</ol>
<h4 id="第7章-单例模式"><a href="#第7章-单例模式" class="headerlink" title="第7章 单例模式"></a>第7章 单例模式</h4><ol>
<li><p>单例模式是怎样的？有什么优缺点？</p>
<ul>
<li>确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。(Ensure a class has only one instance,and provide a global point of access to it.)</li>
<li>优点：<ul>
<li>减少内存开支；减少系统的性能开销；避免对资源的多重占用；优化和共享资源访问。</li>
</ul>
</li>
<li>缺点：<ul>
<li>扩展困难，只能修改代码实现；与单一职责原则有冲突。</li>
</ul>
</li>
</ul>
</li>
<li><p>懒汉式、懒汉式、双重校验、静态内部类、枚举，这五种单例模式分别是怎样的？</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 懒汉模式，线程安全</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LazySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LazySingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">LazySingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> LazySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            instance = <span class="keyword">new</span> LazySingleTon();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 饿汉单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HungrySingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HungrySingleTon instance = <span class="keyword">new</span> HungrySingleTon();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">HungrySingleTon</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HungrySingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 双重校验单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheckSingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheckSingleTon instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheckSingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheckSingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheckSingleTon<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> DoubleCheckSingleTon();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 静态内部类单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClassSingleTon</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleTonHolder</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClassSingleTon instance = <span class="keyword">new</span> StaticInnerClassSingleTon();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClassSingleTon</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClassSingleTon <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingleTonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 枚举单例模式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleTon &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-Hans">
    <link itemprop="mainEntityOfPage" href="http://mlixin.com/2018/09/21/GeekBang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/mLixin.github.io/images/avatar.gif">
      <meta itemprop="name" content="mLiXin">
      <meta itemprop="description" content="Be true to yourself.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="mLiXin's Blog">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/mLixin.github.io/2018/09/21/GeekBang-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%8B%E7%BE%8E/" class="post-title-link" itemprop="url">Geek 数据结构与算法之美 学习笔记</a>
        </h2>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2018-09-21 10:01:53" itemprop="dateCreated datePublished" datetime="2018-09-21T10:01:53+08:00">2018-09-21</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/mLixin.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index"><span itemprop="name">计算机基础</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h4 id="第5讲-数组"><a href="#第5讲-数组" class="headerlink" title="第5讲 数组"></a>第5讲 数组</h4><ol>
<li>什么是数组？<ul>
<li>数组是一种线性表数据结构，它用一组连续的内存空间来存储一组具有相同类型的数据。</li>
<li>数组支持随机访问，根据下标随机访问的时间复杂度为O(1)</li>
</ul>
</li>
<li>那些数据结构是线性表？哪些是非线性表？<ul>
<li>线性表：数组、链表、队列、栈</li>
<li>非线性表：数、图</li>
</ul>
</li>
<li>数组为了保持内存数据的连续性，会导致插入、删除操作比较抵消，为啥？有什么改进方法？<ul>
<li>插入删除后需要移动大量的数据，导致低效</li>
<li>如果数据是有序的，就没办法， 如果数据不是有序的，可以在插入的时候，将原来的数据直接添加到数组尾部；删除的时候，直接将数组尾部的数据添加到当前位置。</li>
</ul>
</li>
<li>Java中的ArrayList和数组相比有什么优势？使用的时候有什么需要注意的点？<ul>
<li>可以将很多数组操作的细节封装起来</li>
<li>支持动态扩容；Java中的ArrayList在存储空间不足的时候，会将空间自动扩容为1.5倍大小。</li>
<li>但是要注意，在扩容的时候涉及内存申请和数据搬移，是比较耗时的，所以如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候指定数据大小。</li>
</ul>
</li>
<li>使用数组和容器比如Java中的ArrayList上有什么需要注意的点？<ul>
<li>Java的ArrayList无法存储基本类型， 比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，如果特别关注性能，或者希望使用基本类型，就可以选用数组</li>
<li>如果数据大小事先一直，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法， 也可以直接使用数组</li>
</ul>
</li>
<li>为什么大多数编程语言中，数组要从0开始编号而不是从1开始？<ul>
<li>从数组存储的内存模型上来看，“下标”最确切的定义应该是“offset”，数组a是用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置。所以从0开始编号的话，每次都能减少一次减法操作，效率的优化做到极致，不过也可能就是历史原因。</li>
</ul>
</li>
<li>JVM的标记清除垃圾回收算法的核心理念是什么？说一下你理解的标记清除垃圾回收算法？<ul>
<li>大部分的虚拟机是采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始</li>
<li>标记和清理的效率都不高，但是在只有少量垃圾产生时才会高效。会产生不连续的内存空间碎片。</li>
</ul>
</li>
<li>二维数组的内存寻址公式是怎样的？<ul>
<li>对于<code>m * n</code>的数组，<code>a[i][j](i&lt;m,j&lt;n)</code>的地址为 <code>address = base_address + (i*n+j)*type_size</code></li>
</ul>
</li>
</ol>
<h4 id="第6、7讲-链表"><a href="#第6、7讲-链表" class="headerlink" title="第6、7讲 链表"></a>第6、7讲 链表</h4><ol>
<li><p>什么是链表</p>
<ul>
<li>链表不需要连续的内存空间，通过“指针”将一组零散的内存卡串联起来。</li>
</ul>
</li>
<li><p>单链表、双向链表、循环链表是怎样的？</p>
<ul>
<li>单链表有两个结点，头结点和尾结点，其中头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表，而尾结点的指针不是指向想一个结点，而是指向一个空地址null，表示这是链表上最后一个节点。</li>
<li>循环链表是一种特殊的单链表，它和单链表唯一的区别是尾结点，循环链表的尾结点指向链表的头结点。约瑟夫问题就可以很简单的通过循环链表解决。</li>
<li>双向链表是支持两个方向，及知道前一个结点的地址，也知道后一个结点的地址。但是双向链表需要额外两个空间来存储后继结点和前驱结点，所以会比单链表占用更多的内存空间。</li>
</ul>
</li>
<li><p>分析删除操作中，删除节点中值等于某个给定值的结点，和删除给定指针指向的结点这两种情况下用哪种链表更好？</p>
<ul>
<li>如果是单链表，两种情况都需要从头开始遍历到指定结点去删除，所以时间复杂度都是O(n);而双向链表在第二种情况下，因为能知道给定结点的前驱指针是哪个，所以第二种情况的时间复杂度是O(1)</li>
</ul>
</li>
<li><p>Java中的LinkedHashMap用到了哪种链表？</p>
<ul>
<li>双向链表</li>
</ul>
</li>
<li><p>用空间换时间是什么意思？举例说明一下</p>
<ul>
<li>当内存空间充足的时候，如果我们更追求代码的执行速度，就可以选择空间复杂度相对较高，但是时间复杂度相对较低的算法或数据结构；相反如果内存比较紧缺，比如代码跑在手机或者单片机上的时候，就要反过来时间换空间了。</li>
<li>换粗就是利用了空间换时间的设计思想。</li>
</ul>
</li>
<li><p>如何基于链表实现LRU缓存淘汰算法？</p>
<ul>
<li>我们维护一个有序单链表，越靠近表尾部的结点是越早之前访问的，当有一个新的数据被访问的时候，我们就从链表头开始遍历链表；<ul>
<li>如果该数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部</li>
<li>如果该数据没有在缓存链表中<ul>
<li>如果缓存未满，直接将此结点直接插入到链表的头部</li>
<li>如果缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么cpu缓存机制使用数组更好？</p>
<ul>
<li>CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中，而CPU每次从内存读取数据并不是只读那个特定的地址，而是读一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要在从内存中取。所以就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异。对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把后面几个下标也加载到CPU缓存中，这样执行速度就会快于存储空间不连续的链表存储。</li>
</ul>
</li>
<li><p>如果字符串是通过单链表来存储的，如何判断是一个回文串？解决思路是什么？相应的时间空间复杂度又是什么？</p>
<ul>
<li>快慢指针，一部分反转，然后遍历比较。</li>
</ul>
</li>
<li><p>对于指针如何理解？</p>
<ul>
<li>将某个变量赋值给指针，实际上就是将这个变量的地址复制给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</li>
</ul>
</li>
<li><p>如何利用哨兵简化实现难度？</p>
<ul>
<li>针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。</li>
</ul>
</li>
<li><p>一般检查链表代码是否正确的边界条件有哪几个？</p>
<ol>
<li>如果链表为空时</li>
<li>如果链表只包含一个结点时</li>
<li>如果链表只包含两个结点时</li>
<li>代码逻辑在处理头结点和尾结点时能否正常工作。</li>
</ol>
</li>
</ol>
<h4 id="第8讲-栈"><a href="#第8讲-栈" class="headerlink" title="第8讲 栈"></a>第8讲 栈</h4><ol>
<li><p>如何实现一个栈？</p>
<ul>
<li>用数组实现的顺序栈：<ul>
<li>构造函数初始化数组</li>
<li>入栈的时候，先判断数组空间是否足够，不够直接返回false，表明入栈失败，足够的话将item放到下标为count的位置，并且count加1</li>
<li>出栈的时候，先判断数组空间是否为空，为空直接返回空，不为空，则返回count-1位置的数组元素，并将count减1</li>
<li>位置为0的地方为栈底，位置为count的地方为栈顶。</li>
</ul>
</li>
<li>用链表实现的链式栈<ul>
<li>链表头部为栈顶，尾部为栈底可以实现。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何实现支持动态扩容的顺序栈？</p>
<ul>
<li>底层依赖一个支持动态扩容的数组就可以了。栈满的时候，申请一个更大的数组，将原来的数据搬移到新数组中。</li>
</ul>
</li>
<li><p>栈在表达式求值中的应用，举例说明34+13x9+44-12/3这个运算是如何处理的？</p>
<ul>
<li>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈，从左到右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，则和运算符栈的栈顶元素进行比较，如果比栈顶的运算符优先级高，就将当前运算符压入栈；否则从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</li>
<li>关键是，取当前运算符和栈顶比较，当前高的时候才入栈，低或者等于都直接计算</li>
</ul>
</li>
<li><p>栈在括号匹配中的应用</p>
<ul>
<li>用栈来保存为匹配的左括号，从左到右依次扫描字符串</li>
<li>当扫描到左括号的时候，直接压入栈中；当扫描到右括号的时候，从栈顶取出一个左括号，如果能匹配，则继续扫描剩下的字符串；如果不能匹配，则说明括号不合法。</li>
</ul>
</li>
<li><p>栈如何实现浏览器的前进、后退功能？</p>
<ul>
<li>用两个栈实现，首次浏览的时候压入栈A，点击后退的时候从A栈出栈，压入栈B，点击前进的时候从栈B出栈，压入栈A。</li>
</ul>
</li>
</ol>
<h4 id="第9讲-队列"><a href="#第9讲-队列" class="headerlink" title="第9讲 队列"></a>第9讲 队列</h4><ol>
<li><p>实现队列的两种方式？如何实现？</p>
<ul>
<li>数组实现的顺序队列<ul>
<li>构造函数申明数组大小，head指向队头下标，tail指向队尾下标</li>
<li>入队的时候判断队满，未满则队尾下标++</li>
<li>出队的时候判断队空，非空则队头下标++</li>
<li>数组不够用的时候可以通过数据搬移处理。可以在入队的时候判断队满，则数据搬移。</li>
</ul>
</li>
<li>链表实现的链式队列<ul>
<li>head指针指向链表的第一个结点，tail指针指向链表的最后一个结点。</li>
<li>链尾入队，链头出队</li>
</ul>
</li>
</ul>
</li>
<li><p>循环队列如何判断队空和队满？</p>
<ul>
<li>队空：head == tail</li>
<li>队满：(tail+1)%n == head</li>
<li>会浪费一个数组的存储空间</li>
</ul>
</li>
<li><p>线程池没有空闲线程时，新的任务请求线程资源的时候，线程池该如何处理？各种处理策略又是如何实现的？</p>
<ul>
<li>非阻塞的处理方式：直接拒绝任务请求</li>
<li>阻塞的处理方式：请求排队，等有空闲线程时，取出排队的请求继续处理。<ul>
<li>基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能导致过多的请求排队等待，请求处理的响应时间过长。</li>
<li>基于数组的实现方式，可以实现一个有界队列，排队的请求超过队列大小的时候，接下来的请求都会被拒绝。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第11、12、13、14讲-排序"><a href="#第11、12、13、14讲-排序" class="headerlink" title="第11、12、13、14讲 排序"></a>第11、12、13、14讲 排序</h4><ol>
<li>冒泡排序如何实现？时间复杂度、空间复杂度、稳定性如何？<ul>
<li>实现<ul>
<li>对相邻的两个元素进行比较，看是否满足大小关系要求，不满足就让它们交换位置。</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(n),要排序的数组已经是有序的</li>
<li>最坏：O(n2),要排序的数组刚好是逆序的</li>
<li>平均：O(n2),可以根据逆序度来计算</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)，原地排序</li>
</ul>
</li>
<li>稳定性<ul>
<li>当相邻的两个元素大小相等的时候不交换，就不会改变顺序，就是稳定的算法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; <span class="comment">// 交换</span></span><br><span class="line">        <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">        a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">        a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">        flag = <span class="keyword">true</span>;  <span class="comment">// 表示有数据交换      </span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;  <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>插入排序如何实现？时间复杂度、空间复杂度、稳定性如何？<ul>
<li>实现思路<ul>
<li>将数组中的数据分为两个空间，已排序区间和未排序区间，取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(n)，要排序的数据已经是有序的，同时从尾到头去遍历已排序好的数组</li>
<li>最坏：O(n2),数组是倒序的</li>
<li>平均：O(n2)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
<li>稳定性<ul>
<li>值相同的元素，选择将后面出现的元素插入到前面出现元素的后面，就能保持稳定。</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> value = a[i];</span><br><span class="line">    <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 查找插入的位置</span></span><br><span class="line">    <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">      <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">        a[j+<span class="number">1</span>] = a[j];  <span class="comment">// 数据移动</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li><p>选择排序如何实现？时间复杂度、空间复杂度、稳定性如何？</p>
<ul>
<li>实现<ul>
<li>也是分已排序区间和未排序区间，然后从未排序区间里找到最小的元素，将其放到已排序区间的末尾</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(n2)</li>
<li>最坏：O(n2)</li>
<li>平均：O(n2)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(1)</li>
</ul>
</li>
<li>稳定性<ul>
<li>不稳定，交换的时候可能将后面的元素交换到前面去了。</li>
</ul>
</li>
</ul>
</li>
<li><p>冒泡排序和插入排序的实际复杂度都是O(n2)，为什么插入排序比冒泡排序更受欢迎？</p>
<ul>
<li>在内层循环里面，冒泡排序需要进行交换，有三个赋值的动作，而插入排序只有一次赋值，所以效率会更高一些。</li>
</ul>
</li>
<li><p>归并排序如何实现？时间复杂度、空间复杂度、稳定性如何？</p>
<ul>
<li>实现<ul>
<li>先从数组中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合在一起。</li>
<li>主要用到分治思想</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>任何情况下都是 ： O(nlogN)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>O(n)</li>
</ul>
</li>
<li>稳定性<ul>
<li>merge的时候，将前面的元素放在前面就能保证是稳定的算法</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推公式：</span></span><br><span class="line"><span class="comment">//merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//终止条件：</span></span><br><span class="line"><span class="comment">//p &gt;= r 不用再继续分解</span></span><br><span class="line"><span class="comment">// 归并排序算法, A 是数组，n 表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">  merge_sort_c(A, <span class="number">0</span>, n-<span class="number">1</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">  <span class="comment">// 递归终止条件</span></span><br><span class="line">  <span class="keyword">if</span> p &gt;= r  then <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 取 p 到 r 之间的中间位置 q</span></span><br><span class="line">  q = (p+r) / <span class="number">2</span></span><br><span class="line">  <span class="comment">// 分治递归</span></span><br><span class="line">  merge_sort_c(A, p, q)</span><br><span class="line">  merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">  <span class="comment">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span></span><br><span class="line">  merge(A[p...r], A[p...q], A[q+<span class="number">1</span>...r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>快速排序如何实现？时间复杂度、空间复杂度、稳定性如何？<ul>
<li>实现<ul>
<li>找到一个分区点，小的放左边，大的放右边，然后再去处理左边和右边</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>最好：O(nLogN),分区均衡</li>
<li>最坏：O(n2),分区不均衡</li>
<li>平均：O(nlogN)</li>
</ul>
</li>
<li>空间复杂度<ul>
<li>可以实现原地的快速排序</li>
</ul>
</li>
<li>稳定性<ul>
<li>可以实现稳定</li>
</ul>
</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递推公式：</span></span><br><span class="line"><span class="comment">//quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//终止条件：</span></span><br><span class="line"><span class="comment">//p &gt;= r</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] quickSort(<span class="keyword">int</span>[] array) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[array.length];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; result.length; i++) &#123;</span><br><span class="line">            result[i] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        quickSort(result, <span class="number">0</span>, result.length - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (start &gt;= end) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> mid = partition(array, start, end);</span><br><span class="line">        quickSort(array, start, mid - <span class="number">1</span>);</span><br><span class="line">        quickSort(array, mid + <span class="number">1</span>, end);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> flag = array[end];</span><br><span class="line">        <span class="keyword">int</span> i = start;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = start; j &lt; end; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[j] &lt; flag) &#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> temp = array[j];</span><br><span class="line">                array[j] = array[i];</span><br><span class="line">                array[i] = temp;</span><br><span class="line"></span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> temp = array[i];</span><br><span class="line">        array[i] = array[end];</span><br><span class="line">        array[end] = temp;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<ol start="7">
<li><p>O(n) 时间复杂度内求无序数组中的第 K 大元素?</p>
<ul>
<li>可以利用快排的原理，以最后的为分界点，如果右边的数组长度大于K，说明第K大元素就在后面，如果p+1 = k，说明A[p]就是要求解的元素</li>
</ul>
</li>
<li><p>如果有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的，你希望将这10个较小的日志文件，合并为1一个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB,有什么解决思路，能快速地将这10个日志文件合并吗？</p>
<ul>
<li>构建10条io流，每次选出时间戳最小的那条数据写入到新的文件中，一次类推。</li>
</ul>
</li>
<li><p>桶排序如何实现？时间、空间复杂度、稳定性如何？适合哪些场景？</p>
<ul>
<li>实现<ul>
<li>将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。</li>
</ul>
</li>
<li>适用场景<ul>
<li>首先，要排序的数据需要很容易就能划分成m个痛，并且桶与桶之间有天然的大小顺序</li>
<li>其次，数据在各个桶之间的分布是比较均匀的，如果不均匀，会退化为快速排序算范</li>
<li>比较适合用在外部排序，就是数据存储在外部磁盘中，数据量比较大，内存优先，无法将数据全部加载到内存中。</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(n),分到m个桶里，每个桶有K = n/m个元素，桶内快速排序，复杂度为O(klogK) * m = O(nlog(n/m)) == O(n)</li>
</ul>
</li>
<li><h2 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h2></li>
<li>稳定性 <ul>
<li>桶内快排是稳定的，所以可以是稳定的。</li>
</ul>
</li>
</ul>
</li>
<li><p>有10GB的订单数据，希望按订单金额来排序，但是内存优先，只有几百MB,没办法一次性把10GB的数据都加载到内存中，这个时候应该怎么办？</p>
<ul>
<li>桶排序，先扫描一遍文件，看看订单金额的数据范围。然后根据订单金额分100个桶或更多，如果一个桶里的数据过多，还可以在桶内再进行桶的划分排序</li>
</ul>
</li>
<li><p>计数排序如何实现？时间、空间复杂度、稳定性如何？适用于哪些场景中？</p>
<ul>
<li>实现<ul>
<li>计数排序可以说是桶排序的一种特殊情况，要排序的n个数据，所处的范围并不大，每个桶内的数据值都是相同的，省掉了桶内排序的时间</li>
</ul>
</li>
<li>适用场景<ul>
<li>只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用基数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下转换为非负整数</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(n)</li>
</ul>
</li>
<li>空间复杂度</li>
<li>稳定性<ul>
<li>可以实现稳定。</li>
</ul>
</li>
</ul>
</li>
<li><p>基数排序如何实现？时间、空间复杂度、稳定性如何？适用于哪些场景中？</p>
<ul>
<li>实现</li>
<li>适用场景<ul>
<li>对要排序的数据是有要求的，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果a数据的高位比b数据大， 那么剩下的地位就不用比较了，初次之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则基数排序的时间复杂度就无法做到O(n)了。</li>
</ul>
</li>
</ul>
</li>
<li><p>假设我们现在需要对D,a,F,B,c,A,z这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为a,c,z,D,F,B,A，这个如何实现？如果字符串中存储的不仅有大小写字母，还有数字，要将小写字母放前面，大写字母放最后，数字翻中间，不用排序算法，有如何解决？</p>
<ul>
<li>只有大小写，前后两个指针，前指针找到大写字母，后指针找到小写字母，交换即可。</li>
<li>如果有大小写和数字的话，可以用桶排序了，也可以先小写和非小写，然后再大写和数字</li>
</ul>
</li>
<li><p>Java中的排序函数是用哪种排序算法实现的？</p>
<ul>
<li>Collections.sort()内部还是用的Arrays.sort()来实现的，</li>
<li>元素个数小于47用插入排序</li>
<li>47到286之间，用快速排序，优化的三值取中的优化版本</li>
<li>大于286使用归并排序(这里还有点存疑，TimSort等，看堆排序里怎么说。)</li>
</ul>
</li>
<li><p>为什么用快速排序而不是归并排序来做基本的排序函数？</p>
<ul>
<li>归并排序需要额外的内存空间，比如要排序100MB的数据，还需要额外再占用100MB的内存空间，而快速排序可以做到原地排序</li>
</ul>
</li>
<li><p>如何优化快速排序？</p>
<ul>
<li>选用合适的分区点<ul>
<li>三数取中法，首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。</li>
<li>随机法，</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第15、16讲-二分查找"><a href="#第15、16讲-二分查找" class="headerlink" title="第15、16讲 二分查找"></a>第15、16讲 二分查找</h4><ol>
<li><p>什么是二分查找？</p>
<ul>
<li>实现思路：<ul>
<li>针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟取件中的中间元素对比，将待查找的区间缩小为之前的一般，直到找到要查找的元素，或者区间被缩小为0</li>
</ul>
</li>
<li>时间复杂度<ul>
<li>O(logN)</li>
</ul>
</li>
</ul>
</li>
<li><p>二分查找的递归和非递归实现</p>
<ul>
<li>代码见底部</li>
<li>非递归实现注意三点<ul>
<li>循环退出条件是low&lt;=hight，有等号</li>
<li>mid取值可以用位运算，防止溢出和优化性能</li>
<li>low和high要+1、-1，不然可能发生死循环</li>
</ul>
</li>
</ul>
</li>
<li><p>二分查找的局限性？</p>
<ul>
<li>二分查找依赖的是数组，不然无法做到O(1)的情况下取到数值</li>
<li>针对的是有序数据，无序的话，无法做到比较大小判断左右</li>
<li>数据量太大、太小都不适合二分查找，太小可以直接顺序遍历，太大的话，可能没有足够的连续空间来存储用来二分查找的数组。</li>
</ul>
</li>
<li><p>如何在1000万个整数中快速查找某个整数？</p>
<ul>
<li>先排序，再利用二分查找算法</li>
<li>不能用散列表或二叉树的原因是，这两者都需要额外的内存空间，而二分查找不需要。</li>
</ul>
</li>
<li><p>如何变成实现“求一个数的平方根”？要求精确到小数点后6位。</p>
<ul>
<li>先二分查找求整数，再求小数点后1位，以此类推。</li>
</ul>
</li>
<li><p>如果用链表存储，二分查找的时间复杂度是多少？为什么用数组而不是二分查找？</p>
<ul>
<li>O(n)，和顺序查找时间复杂度一致，但是比顺序查找还多了一些计算。</li>
</ul>
</li>
<li><p>二分查找的4种常见变形问题？</p>
<ol>
<li>查找第一个值等于给定值的元素</li>
<li>查找最后一个值等于给定值的元素</li>
<li>查找第一个大于等于给定值的元素</li>
<li>查找最后一个大于等于给定值的元素</li>
</ol>
</li>
<li><p>如何快速定位出一个IP地址的归属地？</p>
<ul>
<li>现将IP地址转为32位的整型数并排序好，然后用二分查找。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid = low + ((high - low) &gt;&gt;<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">      <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (low &gt; high) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">    <span class="keyword">return</span> mid;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形1：查找第一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value))&#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形2：查找最后一个值等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形3：查找第一个大于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        high = mid - <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      low = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变形4：查找最后一个小于等于给定值的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch7</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">      high = mid - <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        low = mid + <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第17讲-跳表-tips：了解即可"><a href="#第17讲-跳表-tips：了解即可" class="headerlink" title="第17讲 跳表(tips：了解即可)"></a>第17讲 跳表(tips：了解即可)</h4><ol>
<li><p>什么是跳表？</p>
<ul>
<li>链表上加多级索引的结构就是跳表</li>
<li>是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树。</li>
<li>Redis中的有序集合(Sorted Set)就是用跳表来实现。</li>
</ul>
</li>
<li><p>跳表中查询数据的时间/空间复杂度各是多少？</p>
<ul>
<li>时间复杂度为O(logN)，前提是建立了多级的索引</li>
<li>空间复杂度是O(n)</li>
</ul>
</li>
<li><p>跳表的插入、删除操作如何实现？时间复杂度是多少？</p>
<ul>
<li>插入操作，时间复杂度为O(logN)<ul>
<li>为了保证链表的有序性，插入操作需要先查找到插入的位置(O(logN))然后进行插入操作(O(1))</li>
</ul>
</li>
<li>删除操作，时间复杂度为O(logN)<ul>
<li>删除的时候也是先查找同时拿到前驱结点，然后直接删除。</li>
</ul>
</li>
</ul>
</li>
<li><p>跳表在插入删除等系列操作后可能会退化为单链表，这个时候如何处理？</p>
<ul>
<li>进行索引的动态更新<ul>
<li>通过随机函数实现。随机函数决定将这个结点插入到哪几级索引中，Rubicon随机函数沙僧城了值K，那么我们就讲这个结点添加到第一级到第K级这K级索引中。随机函数需要保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第18、19、20讲-散列表"><a href="#第18、19、20讲-散列表" class="headerlink" title="第18、19、20讲 散列表"></a>第18、19、20讲 散列表</h4><ol>
<li><p>什么是散列表(Hash Table)？</p>
<ul>
<li>散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。</li>
<li>通过散列函数将元素的键值映射为下标，然后将数据存储在数组对应下标的位置。当我们按照键值查询元素的时候，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</li>
</ul>
</li>
<li><p>如何构造散列函数？</p>
<ul>
<li>散列函数计算得到的散列值是一个非负整数</li>
<li>如果key1=key2，那么hash(key1) == hash(key2)</li>
<li>如果key1 != key2,那么hash(key1) != hash(key2)</li>
</ul>
</li>
<li><p>解决散列冲突的两种方法？</p>
<ul>
<li>开放寻址法<ul>
<li>线性探测<ul>
<li>如果出现了散列冲突，就重新探测一个空闲位置，将其插入；删除操作的时候，只能标记为delete不然会出错。</li>
</ul>
</li>
<li>二次探测</li>
<li>双重散列</li>
</ul>
</li>
<li>链表法<ul>
<li>散列值相同的元素都放在相同槽位中对应的链表中。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何设计工业级的散列函数？</p>
<ul>
<li>设计不能太复杂。过于复杂会消耗过多的计算时间</li>
<li>生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突。</li>
</ul>
</li>
<li><p>如何避免低效的扩容？</p>
<ul>
<li>可以将扩容操作穿插在插入操作的过程中，分批完成。当有新数据要插入的时候，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程，经过多次插入操作之后，老的散列表中嘚瑟护甲就一点一点全部搬移到新散列表中了。</li>
</ul>
</li>
<li><p>如何选择冲突解决方法？</p>
<ul>
<li>Java中的LinkedHashMap就采用了链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突的。</li>
<li>开放寻址：<ul>
<li>优点：散列表中的数据都存储在数组中，可以有效地利用cpu缓存加快查询速度。同时序列化比较简单</li>
<li>缺点：删除数据的时候比较麻烦，比起链表法，冲突的代价更高</li>
<li>当数据量比较少、装载因子小的时候，适合用开放寻址法。</li>
</ul>
</li>
<li>链表法：<ul>
<li>优点：内存利用率高；对大装载因子的容忍度更高。</li>
<li>缺点：对CPU缓存不友好</li>
<li>适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</li>
</ul>
</li>
</ul>
</li>
<li><p>分析一下HashMap是如何实现的？</p>
<ul>
<li>初始大小<ul>
<li>默认为16，如果事先知道数据量，可以修改默认初始大小，可以减少动态扩容的次数，会提高HashMap的性能</li>
</ul>
</li>
<li>装载因子和动态扩容<ul>
<li>最大装载因子默认为0.75，每次扩容为原来的两倍</li>
</ul>
</li>
<li>散列冲突解决方法<ul>
<li>链表法解决冲突。在JDK1.8中，当链表长度太长(默认超过8)时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点提高HashMap的性鞥。</li>
</ul>
</li>
<li>散列函数<ul>
<li>就是返回对象的hash code</li>
</ul>
</li>
</ul>
</li>
<li><p>LinkedHashMap是如何实现的？</p>
<ul>
<li>通过双向链表和散列表两种数据结构结合实现的。</li>
</ul>
</li>
</ol>
<h4 id="第23、24讲-二叉树基础"><a href="#第23、24讲-二叉树基础" class="headerlink" title="第23、24讲 二叉树基础"></a>第23、24讲 二叉树基础</h4><ol>
<li><p>二叉树中，节点的高度、深度、层数，树的高度各是什么？</p>
<ul>
<li>节点的高度等于节点到叶子节点的最长路径(边数)</li>
<li>节点的深度等于根节点到这个节点所经历的边的个数</li>
<li>节点的层数等于节点的深度+1</li>
<li>数的高度等于根节点的高度</li>
</ul>
</li>
<li><p>如何表示(或存储)一棵二叉树？</p>
<ul>
<li>基于指针或者引用的二叉链表式存储法<ul>
<li>节点有三个字段，一个存储数据，一个存指向左子节点的指针，一个存指向右子节点的指针</li>
</ul>
</li>
<li>基于数组的顺序存储法<ul>
<li>根节点存储在下标为<code>i = 1</code>的位置，则左子节点存储在<code>2 * i = 2</code>的位置，右子节点存储在<code>2 * i + 1 = 3</code>的位置，以此类推。</li>
<li>适合完全二叉树存储</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉树的三种遍历方式？</p>
<ul>
<li>时间复杂度是O(n)，代码见底部</li>
</ul>
</li>
<li><p>给定一组数据，可以构建出多少种不同的二叉树？</p>
<ul>
<li>N的阶乘</li>
</ul>
</li>
<li><p>什么是二叉查找树？</p>
<ul>
<li>二叉查找树是为了实现快速查找而生的，二叉查找树要求，在树中的任意一个节点，其左子树中每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。</li>
</ul>
</li>
<li><p>二叉查找树的查找、插入、删除操作流程？</p>
<ul>
<li>查找：<ul>
<li>先取根节点，如果它等于target，直接返回</li>
<li>如果target比根节点小，在左子树中递归查找</li>
<li>如果target比根节点大，在右子树中递归查找。</li>
</ul>
</li>
<li>插入：<ul>
<li>新插入的数据一般都是在叶子节点的，先查找，然后判断大小插入左子树还是右子树中</li>
</ul>
</li>
<li>删除：<ul>
<li>删除的结点没有子节点<ul>
<li>直接删除，拿到父节点指向该节点的指针置为null即可</li>
</ul>
</li>
<li>删除的阶段只有一个子节点<ul>
<li>将父节点指向该节点的指针指向该节点的子节点</li>
</ul>
</li>
<li>删除的结点有两个子节点 <ul>
<li>找到这个节点的右子树中的最小节点，把它替换到要删除的结点上，然后再删除这个最小节点。 </li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>二叉查找树的中序遍历有什么特点？</p>
<ul>
<li>输出的是有序的数据序列，时间复杂度是O(n)，所以二叉查找树也称为二叉排序树</li>
</ul>
</li>
<li><p>散列表的插入、删除、查找操作的实际复杂度可以做到常量级的O(1),非常搞笑。而二叉查找树在比较平衡的情况下，插入、删除、查找操作实际复杂度才是O(logN)，相对散列表好像没有什么优势，为什么还要用二叉查找树呢？</p>
<ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，进行一遍中序遍历就可以了。可以在O(n)的时间复杂度内输出。</li>
<li>散列表扩容耗时很多，而且遇到散列冲突时，性能不稳定。而常用的平衡二叉树的性能非常稳定，时间复杂度稳定在O(logN)</li>
<li>尽管散列表的查找等操作的实际复杂度是常量级的，但是因为哈希冲突的存在，这个常量不一定比logN小，所以实际的查找时间不一定比O(logN)快，加上哈希函数的耗时，不一定比平衡二叉树的效率高。</li>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多，如散列函数的设计、冲突解决方法、扩容、缩容等。而平衡二叉查找树只需要考虑平衡性这一个问题。</li>
<li>为了避免过多的散列冲突，散列表装载因子不能太大，不然会浪费一定的存储空间。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">  preOrder(root-&gt;left);</span><br><span class="line">  preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  inOrder(root-&gt;left);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">  inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">  postOrder(root-&gt;left);</span><br><span class="line">  postOrder(root-&gt;right);</span><br><span class="line">  print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第25、26讲-红黑树"><a href="#第25、26讲-红黑树" class="headerlink" title="第25、26讲 红黑树"></a>第25、26讲 红黑树</h4><ol>
<li><p>什么是平衡二叉树？什么是平衡二叉查找树？</p>
<ul>
<li>平衡二叉树要求，二叉树中任意一个节点的左右子树的高度相差不能大于1.</li>
<li>平衡二叉查找树则满足平衡二叉树和二叉查找树两个定义。</li>
</ul>
</li>
<li><p>什么是红黑树？有什么要求？</p>
<ul>
<li>红黑树中的节点，一类被标记为黑色，一类被标记为红色，除此之外：<ul>
<li>根节点是黑色的</li>
<li>每个叶子节点都是黑色的空节点(NIL)，也就是说叶子节点不存储数据(简化红黑树的代码实现而设置)</li>
<li>任何相邻的结点都不能同时为红色，也就是说红色节点是被黑色节点隔开的。</li>
<li>每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。</li>
</ul>
</li>
<li>红黑树的高度近似logN，所以它是近似平衡的，插入、删除、查找操作的时间复杂度都是O(logN)</li>
<li>红黑树是一种性能非常稳定的二叉查找树，所以在工程中，凡是用到动态插入、删除、查找数据的场景，都可以用到它。 </li>
<li>自己实现困难，可以用跳表替换</li>
</ul>
</li>
<li><p>为什么说红黑树是近似平衡的？</p>
<ul>
<li>黑色节点取出来，是一个完全四叉树，所以只是多一倍的空间。</li>
</ul>
</li>
<li><p>动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，还有哪些？比较一下各自的优势、劣势、应用场景。</p>
<ul>
<li>散列表<ul>
<li>O(1),最常用，缺点是不能顺序遍历，及扩容缩容的性能损耗</li>
</ul>
</li>
<li>跳表<ul>
<li>O(logN)，能顺序遍历，缺点是空间复杂度O(n)，使用不在意内存空间的场景</li>
</ul>
</li>
<li>红黑树<ul>
<li>O(logN)，中序遍历即顺序遍历，稳定，缺点是难以实现，可以用跳表替换。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何自己实现一个红黑树？</p>
<ul>
<li>基本思想：遇到什么样的节点排布，我们就对应怎么去调整<ul>
<li>左旋</li>
<li>右旋</li>
</ul>
</li>
<li>插入操作的平衡调整：红黑树规定，插入的节点必须是红色的，而且二叉查找树中新插入的节点都是放在叶子节点上。<ul>
<li>如果插入节点的父节点是黑色的，不用调整，满足</li>
<li>如果插入的节点是根节点，直接改变颜色，变成黑色即可。</li>
<li>其他情况：需要做左右旋转和改变颜色，正在处理的节点为关注节点，关注节点会随着迭代而变化，最开始的关注节点是新插入的节点。<ul>
<li>case1 ：如果关注节点的叔叔节点是红色的<ul>
<li>将关注节点的父节点、叔叔节点都设置成黑色</li>
<li>将关注节点的祖父节点设置为红色</li>
<li>关注节点变化为祖父节点</li>
<li>调到case2或case3</li>
</ul>
</li>
<li>case2 ：如果关注节点的叔叔节点是黑色的，关注节点是其父节点的右子节点<ul>
<li>关注节点变化为父节点</li>
<li>围绕将新的关注节点左旋</li>
<li>调到case3</li>
</ul>
</li>
<li>case3 ： 如果关注节点的叔叔节点是黑色，关注节点是其父节点的左子节点<ul>
<li>围绕关注节点的祖父节点右旋</li>
<li>将新树中，关注节点的父节点和关注节点的兄弟节点颜色互换</li>
<li>调整结束。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>删除操作的平衡调整，分两步<ul>
<li>针对删除结点初步调整</li>
<li>针对关注节点进行二次调整</li>
<li>过。有时间有闲心再来背这个吧。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第28、29讲-堆和堆排序、堆的应用"><a href="#第28、29讲-堆和堆排序、堆的应用" class="headerlink" title="第28、29讲 堆和堆排序、堆的应用"></a>第28、29讲 堆和堆排序、堆的应用</h4><ol>
<li><p>堆是怎样的？有什么要求？</p>
<ul>
<li>堆是一个完全二叉树</li>
<li>堆中每个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。</li>
</ul>
</li>
<li><p>如何实现一个堆？</p>
<ul>
<li>往堆中插入一个元素<ul>
<li>从下往上堆化<ul>
<li>因为每次插入都是插入在堆的最后，每次比较关注节点和父节点，不满足大小关系就互换。</li>
</ul>
</li>
</ul>
</li>
<li>删除堆顶元素<ul>
<li>从上往下堆化。删除元素后，先将堆尾元素补充到删除元素位置，然后做从上往下堆化。</li>
</ul>
</li>
<li>往堆中插入、删除堆顶元素的时间复杂度都是O(logN)</li>
</ul>
</li>
<li><p>如何基于堆实现排序？</p>
<ul>
<li>时间复杂度为O(nlogN)的原地排序</li>
<li>建堆，时间复杂度是O(n)<ul>
<li>从后往前处理数组，每个数据都是从上往下堆化。叶子节点没有子节点，可以从后往前第一个父节点开始堆化。</li>
</ul>
</li>
<li>排序，时间复杂度是O(nlogN)<ul>
<li>数组的第一个元素是堆顶，是最小或者最大的元素，将它和n位置的元素互换，然后将前面n-1个元素堆化，继续将第一个和n-1位置的元素互换，一直重复。</li>
</ul>
</li>
</ul>
</li>
<li><p>为什么在实际开发中，快读排序要比堆排序性能好？</p>
<ul>
<li>堆排序数据访问的方式没有快速排序友好。堆排序数据是跳着访问的，对CPU缓存不友好</li>
<li>对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。</li>
</ul>
</li>
<li><p>堆的应用场景？</p>
<ul>
<li>优先级队列</li>
<li>利用堆求Top K</li>
<li>利用堆求中位数</li>
</ul>
</li>
</ol>
<h4 id="第30、31讲-图的表示，及深度、广度优先搜索算法"><a href="#第30、31讲-图的表示，及深度、广度优先搜索算法" class="headerlink" title="第30、31讲 图的表示，及深度、广度优先搜索算法"></a>第30、31讲 图的表示，及深度、广度优先搜索算法</h4><ol>
<li><p>如何理解“图”？</p>
<ul>
<li>非线性表数据结构</li>
<li>图中的元素叫做顶点，图的一个顶点可以与任意其他顶点建立连接关系，这种建立的关系叫做边。跟顶点相连接的边的条数就是顶点的度。</li>
<li>有方向的图叫做有向图，没有方向的图叫做无向图</li>
<li>有向图中，有多少条表指向这个顶点成为入度；有多少条边是以这个顶点为七店指向其他顶点的，叫做顶点的出度。</li>
<li>每条边都有一个权重的，叫做带权图。</li>
</ul>
</li>
<li><p>如何在内存中存储图这种数据结构？</p>
<ul>
<li>邻接矩阵(二维数组)<ul>
<li>空间换时间</li>
<li>优点是：存储方式简单、直接，获取两个顶点的关系的时候非常高效；方便计算，可以将很多图的运算转换成矩阵之间的计算。</li>
<li>缺点是：可能比较浪费存储空间</li>
</ul>
</li>
<li>邻接表<ul>
<li>时间换空间</li>
</ul>
</li>
</ul>
</li>
<li><p>广度优先搜索BFS如何实现？</p>
<ul>
<li>先查找离起始顶点最近的，然后是次近的，一次往外搜索。</li>
<li>时间复杂度：O(V+E),V表示顶点的个数，E表示边的个数</li>
<li>空间复杂度：O(V),V表示顶点的个数</li>
</ul>
</li>
<li><p>深度优先搜索DFS如何实现？</p>
<ul>
<li>优先沿着一条路径一直走下去，没有路了再回来找其他的路径，回溯思想。</li>
<li>时间复杂度：O(E),E表示边的个数</li>
<li>空间复杂度：O(V),V表示顶点的个数</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 广度优先搜索</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (s == t) <span class="keyword">return</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  visited[s]=<span class="keyword">true</span>;</span><br><span class="line">  Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">  queue.add(s);</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">      <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">      <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">        prev[q] = w;</span><br><span class="line">        <span class="keyword">if</span> (q == t) &#123;</span><br><span class="line">          print(prev, s, t);</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[q] = <span class="keyword">true</span>;</span><br><span class="line">        queue.add(q);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123; <span class="comment">// 递归打印 s-&gt;t 的路径</span></span><br><span class="line">  <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) &#123;</span><br><span class="line">    print(prev, s, prev[t]);</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 深度优先搜索</span></span><br><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">  found = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">  <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) &#123;</span><br><span class="line">    prev[i] = -<span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  recurDfs(s, t, visited, prev);</span><br><span class="line">  print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="keyword">true</span>) <span class="keyword">return</span>;</span><br><span class="line">  visited[w] = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">if</span> (w == t) &#123;</span><br><span class="line">    found = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">    <span class="keyword">if</span> (!visited[q]) &#123;</span><br><span class="line">      prev[q] = w;</span><br><span class="line">      recurDfs(q, t, visited, prev);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="第32、33、34讲-字符串匹配基础"><a href="#第32、33、34讲-字符串匹配基础" class="headerlink" title="第32、33、34讲 字符串匹配基础"></a>第32、33、34讲 字符串匹配基础</h4><ol>
<li><p>BF算法(Brute Force算法，暴力匹配算法，朴素匹配算法)</p>
<ul>
<li>在主串中，检查起始位置分别是0、1、2、3…n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配。</li>
<li>最坏情况下的时间复杂度是O(n*m)</li>
<li>实际开发中是一个常用的字符串匹配算法：<ul>
<li>实际开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串的子串匹配的时候，当中图遇到不能匹配的字符的时候，就可以停止了，不需要把m个字符都比对一下。</li>
<li>算法思想简单，代码实现也简单。</li>
</ul>
</li>
</ul>
</li>
<li><p>RK算法(Rabin-Karp算法)</p>
<ul>
<li>借助哈希算法对BF算法进行改造：通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。</li>
<li>时间复杂度：O(n)，极端情况下，大量哈希冲突，退化为O(n*m)</li>
<li>哈希冲突存在，所以可以比较哈希值相等的时候，再对比一下子串和模式串本身就好了。</li>
</ul>
</li>
<li><p>BM算法(Boyer-Moore)算法</p>
<ul>
<li>非常高效的字符串匹配算法，性能是著名的KMP算法的3到4倍。在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。主要包括坏字符和好后缀规则。</li>
<li>坏字符规则<ul>
<li>从后往前匹配，找到第一个坏字符，然后在模式串中查找这个坏字符，si表示坏字符对应的模式传中字符下标，xi表示坏字符在模式串中存在，这个下标记为xi，如果不存在，则xi为-1，则模式串往后移动的位数就等于si-xi。注意xi以从后往前顺序获取，避免过度滑动。</li>
</ul>
</li>
<li>好后缀规则<ul>
<li>已经匹配好的后缀记作{u}，拿它在模式串中查找<ul>
<li>如果找到了另外一个匹配的子串{u*}，九江模式串滑动到对齐的位置</li>
<li>如果没有找到，就看好后缀的后缀子串是否存在跟模式串的前缀子串匹配的。有的话就滑动到对齐位置，没有的话，就直接滑动到好后缀的后面</li>
</ul>
</li>
</ul>
</li>
<li>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。 </li>
</ul>
</li>
<li><p>KMP算法(Knuth Morris Pratt算法) - todo</p>
<ul>
<li>坏字符</li>
<li>好前缀</li>
</ul>
</li>
</ol>
<h4 id="第37讲-贪心算法"><a href="#第37讲-贪心算法" class="headerlink" title="第37讲 贪心算法"></a>第37讲 贪心算法</h4><ol>
<li><p>贪心算法有哪些应用？</p>
<ul>
<li>霍夫曼编码(Huffman Coding)</li>
<li>Prim和Kruskal最小生成树算法</li>
<li>Dijkstra单源最短路径算法</li>
</ul>
</li>
<li><p>如何理解贪心算法？</p>
<ul>
<li>解题步骤<ul>
<li>看到这类问题，首先联想到贪心算法：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大</li>
<li>尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据</li>
<li>举几个例子看下贪心算法产生的结果是否是最优的。</li>
</ul>
</li>
<li>用贪心算法解决问题的思路，并不总能给出最优解。如果前面的选择会影响后面的选择，这种情况下，贪心算法就不能给出最优解了。</li>
</ul>
</li>
<li><p>举例说明一下是如何运用贪心算法的？</p>
<ul>
<li>分糖果<ul>
<li>期望值是满足需求的人数越多，限制值是一定的糖果总量。可以优先满足需求低的。</li>
</ul>
</li>
<li>钱币找零<ul>
<li>限制值是纸币面值一定，期望值是张数越少。可以优先用面值大的，然后继续用面值小的。</li>
</ul>
</li>
<li>区间覆盖<ul>
<li>假设这n个区间中最左端点是lmin，最右是rmax。每次选择的时候，左端点跟前面的已经覆盖的区间不重合，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。</li>
</ul>
</li>
</ul>
</li>
<li><p>如何用贪心算法实现霍夫曼编码？</p>
<ul>
<li>霍夫曼编码是一种有效的编码方法，用于数据压缩中，其压缩率通常在20%~90%之间。</li>
<li>不仅考察文本中有多少个不同字符，还会考察每个字符出现的频率，频率较多的字符用稍微短一些的编码；频率比较少的，用稍微长一些的编码。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码直接不会出现某个编码是另一个编码前缀的情况。</li>
</ul>
</li>
<li><p>在一个非负整数a中，我们希望从中移除k个数字，让剩下的数字最小，如何选择移除哪k个数字呢？</p>
<ul>
<li>由最高位开始，如果低位比它小，则移除它；否则右移一位判断。</li>
</ul>
</li>
<li><p>假设有n个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同改的，如何安排被服务的先后顺序，才能让这n个人总的等待时间最短？</p>
<ul>
<li>优先选择服务时间最短的</li>
</ul>
</li>
</ol>
<h4 id="第38讲-分治算法"><a href="#第38讲-分治算法" class="headerlink" title="第38讲 分治算法"></a>第38讲 分治算法</h4><ol>
<li>如何理解分治算法？<ul>
<li>分治算法能解决的问题，一般需要满足以下条件：<ul>
<li>原问题与分解成的小问题具有相同的模式</li>
<li>原问题分解成的子问题可以独立求解，子问题之间没有相关性</li>
<li>具有分解终止条件，当问题足够小的时候，可以直接求解</li>
<li>可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果。</li>
</ul>
</li>
<li>分治算法每层递归都会涉及这样三个操作：<ul>
<li>分解：将原问题分解成一系列子问题</li>
<li>解决：递归地求解各个子问题，若子问题足够小，则直接求解</li>
<li>合并：将子问题的结果合并成原问题</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="第39讲-回溯算法"><a href="#第39讲-回溯算法" class="headerlink" title="第39讲 回溯算法"></a>第39讲 回溯算法</h4><ol>
<li>如何理解回溯算法？<ul>
<li>类似枚举搜索：枚举所有的解，找到满足期望的解</li>
</ul>
</li>
<li>回溯算法的经典应用：八皇后问题<ul>
<li>依次将8个棋子放到第一行、第二行、第三行。。。第巴行，放置的过程中，不停地检查当前的方法是否满足要求。如果满足，则跳到下一行继续放置；如果不满足，就换一种方法继续尝试。</li>
</ul>
</li>
<li>回溯算法的经典应用：0-1书包问题<ul>
<li>将物品依次排列，整个问题就分解成了n个阶段，每个阶段对一个一个物品怎么选择：装进去或者不装进去，然后再递归地处理剩下的物品。</li>
</ul>
</li>
<li>回溯算法的经典应用：正则表达式<ul>
<li>依次考察正则表达式中的每个字符，当是非通配符的时候，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 八皇后问题</span></span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>];<span class="comment">// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span>&#123; <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">  <span class="keyword">if</span> (row == <span class="number">8</span>) &#123; <span class="comment">// 8 个棋子都放置好了，打印结果</span></span><br><span class="line">    printQueens(result);</span><br><span class="line">    <span class="keyword">return</span>; <span class="comment">// 8 行棋子都放好了，已经没法再往下递归了，所以就 return</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123; <span class="comment">// 每一行都有 8 中放法</span></span><br><span class="line">    <span class="keyword">if</span> (isOk(row, column)) &#123; <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">      result[row] = column; <span class="comment">// 第 row 行的棋子放到了 column 列</span></span><br><span class="line">      cal8queens(row+<span class="number">1</span>); <span class="comment">// 考察下一行</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span>&#123;<span class="comment">// 判断 row 行 column 列放置是否合适</span></span><br><span class="line">  <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123; <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">    <span class="keyword">if</span> (result[i] == column) <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第 i 行的 column 列有棋子吗？</span></span><br><span class="line">    <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) &#123; <span class="comment">// 考察左上对角线：第 i 行 leftup 列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == leftup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) &#123; <span class="comment">// 考察右上对角线：第 i 行 rightup 列有棋子吗？</span></span><br><span class="line">      <span class="keyword">if</span> (result[i] == rightup) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    --leftup; ++rightup;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span>&#123; <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) &#123;</span><br><span class="line">      <span class="keyword">if</span> (result[row] == column) System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">      <span class="keyword">else</span> System.out.print(<span class="string">"* "</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0-1背包问题</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">// 存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；</span></span><br><span class="line"><span class="comment">// w 背包重量；items 表示每个物品的重量；n 表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (cw == w || i == n) &#123; <span class="comment">// cw==w 表示装满了 ;i==n 表示已经考察完所有的物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw &gt; maxW) maxW = cw;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  f(i+<span class="number">1</span>, cw, items, n, w);</span><br><span class="line">  <span class="keyword">if</span> (cw + items[i] &lt;= w) &#123;<span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">    f(i+<span class="number">1</span>,cw + items[i], items, n, w);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正则表达式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">int</span> plen; <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">    <span class="keyword">this</span>.plen = plen;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123; <span class="comment">// 文本串及长度</span></span><br><span class="line">    matched = <span class="keyword">false</span>;</span><br><span class="line">    rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">    <span class="keyword">return</span> matched;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (matched) <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">    <span class="keyword">if</span> (pj == plen) &#123; <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">      <span class="keyword">if</span> (ti == tlen) matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) &#123; <span class="comment">// * 匹配任意个字符</span></span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) &#123;</span><br><span class="line">        rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) &#123; <span class="comment">// ? 匹配 0 个或者 1 个字符</span></span><br><span class="line">      rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) &#123; <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">      rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="第40讲-动态规划"><a href="#第40讲-动态规划" class="headerlink" title="第40讲 动态规划"></a>第40讲 动态规划</h4>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/mLixin.github.io/page/8/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/mLixin.github.io/">1</a><span class="space">&hellip;</span><a class="page-number" href="/mLixin.github.io/page/8/">8</a><span class="page-number current">9</span><a class="page-number" href="/mLixin.github.io/page/10/">10</a><a class="page-number" href="/mLixin.github.io/page/11/">11</a><a class="extend next" rel="next" href="/mLixin.github.io/page/10/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">mLiXin</p>
  <div class="site-description" itemprop="description">Be true to yourself.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/mLixin.github.io/archives/">
        
          <span class="site-state-item-count">101</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/mLixin.github.io/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/mLixin.github.io/tags/">
          
        <span class="site-state-item-count">41</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2017 – 
  <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">mLiXin</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/mLixin.github.io/lib/anime.min.js"></script>
  <script src="/mLixin.github.io/lib/velocity/velocity.min.js"></script>
  <script src="/mLixin.github.io/lib/velocity/velocity.ui.min.js"></script>

<script src="/mLixin.github.io/js/utils.js"></script>

<script src="/mLixin.github.io/js/motion.js"></script>


<script src="/mLixin.github.io/js/schemes/muse.js"></script>


<script src="/mLixin.github.io/js/next-boot.js"></script>




  















  

  
  <script src="//cdn.jsdelivr.net/npm/quicklink@1/dist/quicklink.umd.js"></script>
  <script>
      window.addEventListener('load', () => {
      quicklink({
        timeout : 3000,
        priority: true,
        ignores : [uri => uri.includes('#'),uri => uri === 'http://mlixin.com/page/9/',]
      });
      });
  </script>

</body>
</html>
