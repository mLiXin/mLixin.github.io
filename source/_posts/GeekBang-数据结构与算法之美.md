---
title: Geek 数据结构与算法之美 学习笔记
date: 2018-09-21 10:01:53
tags:
- 计算机基础
- 数据结构与算法
categories:
- 计算机基础
---
#### 第5讲 数组
1. 什么是数组？
    - 数组是一种线性表数据结构，它用一组连续的内存空间来存储一组具有相同类型的数据。
    - 数组支持随机访问，根据下标随机访问的时间复杂度为O(1)
2. 那些数据结构是线性表？哪些是非线性表？
    - 线性表：数组、链表、队列、栈
    - 非线性表：数、图
3. 数组为了保持内存数据的连续性，会导致插入、删除操作比较抵消，为啥？有什么改进方法？
    - 插入删除后需要移动大量的数据，导致低效
    - 如果数据是有序的，就没办法， 如果数据不是有序的，可以在插入的时候，将原来的数据直接添加到数组尾部；删除的时候，直接将数组尾部的数据添加到当前位置。
4. Java中的ArrayList和数组相比有什么优势？使用的时候有什么需要注意的点？
    - 可以将很多数组操作的细节封装起来
    - 支持动态扩容；Java中的ArrayList在存储空间不足的时候，会将空间自动扩容为1.5倍大小。
    - 但是要注意，在扩容的时候涉及内存申请和数据搬移，是比较耗时的，所以如果事先能确定需要存储的数据大小，最好在创建ArrayList的时候指定数据大小。
5. 使用数组和容器比如Java中的ArrayList上有什么需要注意的点？
    - Java的ArrayList无法存储基本类型， 比如int、long，需要封装为Integer、Long类，而Autoboxing、Unboxing则有一定的性能消耗，如果特别关注性能，或者希望使用基本类型，就可以选用数组
    - 如果数据大小事先一直，并且对数据的操作非常简单，用不到ArrayList提供的大部分方法， 也可以直接使用数组
6. 为什么大多数编程语言中，数组要从0开始编号而不是从1开始？
    - 从数组存储的内存模型上来看，“下标”最确切的定义应该是“offset”，数组a是用a来表示数组的首地址，a[0]就是偏移为0的位置，也就是首地址，a[k]就表示偏移k个type_size的位置。所以从0开始编号的话，每次都能减少一次减法操作，效率的优化做到极致，不过也可能就是历史原因。
7. JVM的标记清除垃圾回收算法的核心理念是什么？说一下你理解的标记清除垃圾回收算法？
    - 大部分的虚拟机是采用可达性分析算法来判断对象是否存活，在标记阶段，会遍历所有GC ROOTS，将所有GC ROOTS可达的对象标记为存活。只有当标记工作完成后，清理工作才会开始
    - 标记和清理的效率都不高，但是在只有少量垃圾产生时才会高效。会产生不连续的内存空间碎片。
8. 二维数组的内存寻址公式是怎样的？
    - 对于`m * n`的数组，`a[i][j](i<m,j<n)`的地址为 `address = base_address + (i*n+j)*type_size`

#### 第6、7讲 链表
1. 什么是链表
    - 链表不需要连续的内存空间，通过“指针”将一组零散的内存卡串联起来。

2. 单链表、双向链表、循环链表是怎样的？
    - 单链表有两个结点，头结点和尾结点，其中头结点用来记录链表的基地址，有了它，我们就可以遍历得到整条链表，而尾结点的指针不是指向想一个结点，而是指向一个空地址null，表示这是链表上最后一个节点。
    - 循环链表是一种特殊的单链表，它和单链表唯一的区别是尾结点，循环链表的尾结点指向链表的头结点。约瑟夫问题就可以很简单的通过循环链表解决。
    - 双向链表是支持两个方向，及知道前一个结点的地址，也知道后一个结点的地址。但是双向链表需要额外两个空间来存储后继结点和前驱结点，所以会比单链表占用更多的内存空间。

3. 分析删除操作中，删除节点中值等于某个给定值的结点，和删除给定指针指向的结点这两种情况下用哪种链表更好？
    - 如果是单链表，两种情况都需要从头开始遍历到指定结点去删除，所以时间复杂度都是O(n);而双向链表在第二种情况下，因为能知道给定结点的前驱指针是哪个，所以第二种情况的时间复杂度是O(1)

4. Java中的LinkedHashMap用到了哪种链表？
    - 双向链表

5. 用空间换时间是什么意思？举例说明一下
    - 当内存空间充足的时候，如果我们更追求代码的执行速度，就可以选择空间复杂度相对较高，但是时间复杂度相对较低的算法或数据结构；相反如果内存比较紧缺，比如代码跑在手机或者单片机上的时候，就要反过来时间换空间了。
    - 换粗就是利用了空间换时间的设计思想。

6. 如何基于链表实现LRU缓存淘汰算法？
    - 我们维护一个有序单链表，越靠近表尾部的结点是越早之前访问的，当有一个新的数据被访问的时候，我们就从链表头开始遍历链表；
        - 如果该数据之前已经被缓存在链表中，我们遍历得到这个数据对应的结点，并将其从原来的位置删除，然后再插入到链表的头部
        - 如果该数据没有在缓存链表中
            - 如果缓存未满，直接将此结点直接插入到链表的头部
            - 如果缓存已满，则链表尾结点删除，将新的数据结点插入链表的头部。

7. 为什么cpu缓存机制使用数组更好？
    - CPU在从内存读取数据的时候，会先把读取到的数据加载到CPU的缓存中，而CPU每次从内存读取数据并不是只读那个特定的地址，而是读一个数据块并保存到CPU缓存中，然后下次访问内存数据的时候就会先从CPU缓存开始查找，如果找到就不需要在从内存中取。所以就实现了比内存访问速度更快的机制，也就是CPU缓存存在的意义：为了弥补内存访问速度过慢与CPU执行速度快之间的差异。对于数组来说，存储空间是连续的，所以在加载某个下标的时候可以把后面几个下标也加载到CPU缓存中，这样执行速度就会快于存储空间不连续的链表存储。

8. 如果字符串是通过单链表来存储的，如何判断是一个回文串？解决思路是什么？相应的时间空间复杂度又是什么？
    - 快慢指针，一部分反转，然后遍历比较。

9. 对于指针如何理解？
    - 将某个变量赋值给指针，实际上就是将这个变量的地址复制给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。

10. 如何利用哨兵简化实现难度？
    - 针对链表的插入、删除操作，需要对插入第一个节点和删除最后一个节点的情况进行特殊处理。

11. 一般检查链表代码是否正确的边界条件有哪几个？
    1. 如果链表为空时
    2. 如果链表只包含一个结点时
    3. 如果链表只包含两个结点时
    4. 代码逻辑在处理头结点和尾结点时能否正常工作。

#### 第8讲 栈
1. 如何实现一个栈？
    - 用数组实现的顺序栈：
        - 构造函数初始化数组
        - 入栈的时候，先判断数组空间是否足够，不够直接返回false，表明入栈失败，足够的话将item放到下标为count的位置，并且count加1
        - 出栈的时候，先判断数组空间是否为空，为空直接返回空，不为空，则返回count-1位置的数组元素，并将count减1
        - 位置为0的地方为栈底，位置为count的地方为栈顶。
    - 用链表实现的链式栈
        - 链表头部为栈顶，尾部为栈底可以实现。

2. 如何实现支持动态扩容的顺序栈？
    - 底层依赖一个支持动态扩容的数组就可以了。栈满的时候，申请一个更大的数组，将原来的数据搬移到新数组中。

3. 栈在表达式求值中的应用，举例说明34+13x9+44-12/3这个运算是如何处理的？
    - 实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈，从左到右遍历表达式，当遇到数字，就直接压入操作数栈；当遇到运算符，则和运算符栈的栈顶元素进行比较，如果比栈顶的运算符优先级高，就将当前运算符压入栈；否则从运算符栈中取栈顶运算符，从操作数栈的栈顶取两个操作数，然后进行计算，再把计算完的结果压入操作数栈，继续比较。
    - 关键是，取当前运算符和栈顶比较，当前高的时候才入栈，低或者等于都直接计算

4. 栈在括号匹配中的应用
    - 用栈来保存为匹配的左括号，从左到右依次扫描字符串
    - 当扫描到左括号的时候，直接压入栈中；当扫描到右括号的时候，从栈顶取出一个左括号，如果能匹配，则继续扫描剩下的字符串；如果不能匹配，则说明括号不合法。

5. 栈如何实现浏览器的前进、后退功能？
    - 用两个栈实现，首次浏览的时候压入栈A，点击后退的时候从A栈出栈，压入栈B，点击前进的时候从栈B出栈，压入栈A。

#### 第9讲 队列
1. 实现队列的两种方式？如何实现？
    - 数组实现的顺序队列
        - 构造函数申明数组大小，head指向队头下标，tail指向队尾下标
        - 入队的时候判断队满，未满则队尾下标++
        - 出队的时候判断队空，非空则队头下标++
        - 数组不够用的时候可以通过数据搬移处理。可以在入队的时候判断队满，则数据搬移。
    - 链表实现的链式队列
        - head指针指向链表的第一个结点，tail指针指向链表的最后一个结点。
        - 链尾入队，链头出队

2. 循环队列如何判断队空和队满？
    - 队空：head == tail
    - 队满：(tail+1)%n == head
    - 会浪费一个数组的存储空间

3. 线程池没有空闲线程时，新的任务请求线程资源的时候，线程池该如何处理？各种处理策略又是如何实现的？
    - 非阻塞的处理方式：直接拒绝任务请求
    - 阻塞的处理方式：请求排队，等有空闲线程时，取出排队的请求继续处理。
        - 基于链表的实现方式，可以实现一个支持无限排队的无界队列，但是可能导致过多的请求排队等待，请求处理的响应时间过长。
        - 基于数组的实现方式，可以实现一个有界队列，排队的请求超过队列大小的时候，接下来的请求都会被拒绝。

#### 第11、12、13、14讲 排序
1. 冒泡排序如何实现？时间复杂度、空间复杂度、稳定性如何？
    - 实现
        - 对相邻的两个元素进行比较，看是否满足大小关系要求，不满足就让它们交换位置。
    - 时间复杂度
        - 最好：O(n),要排序的数组已经是有序的
        - 最坏：O(n2),要排序的数组刚好是逆序的
        - 平均：O(n2),可以根据逆序度来计算
    - 空间复杂度
        - O(1)，原地排序
    - 稳定性
        - 当相邻的两个元素大小相等的时候不交换，就不会改变顺序，就是稳定的算法。

```Java
// 冒泡排序，a 表示数组，n 表示数组大小
public void bubbleSort(int[] a, int n) {
  if (n <= 1) return;
 
 for (int i = 0; i < n; ++i) {
    // 提前退出冒泡循环的标志位
    boolean flag = false;
    for (int j = 0; j < n - i - 1; ++j) {
      if (a[j] > a[j+1]) { // 交换
        int tmp = a[j];
        a[j] = a[j+1];
        a[j+1] = tmp;
        flag = true;  // 表示有数据交换      
      }
    }
    if (!flag) break;  // 没有数据交换，提前退出
  }
}

```

2. 插入排序如何实现？时间复杂度、空间复杂度、稳定性如何？
    - 实现思路
        - 将数组中的数据分为两个空间，已排序区间和未排序区间，取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入
    - 时间复杂度
        - 最好：O(n)，要排序的数据已经是有序的，同时从尾到头去遍历已排序好的数组
        - 最坏：O(n2),数组是倒序的
        - 平均：O(n2)
    - 空间复杂度
        - O(1)
    - 稳定性
        - 值相同的元素，选择将后面出现的元素插入到前面出现元素的后面，就能保持稳定。

        
```Java
// 插入排序，a 表示数组，n 表示数组大小
public void insertionSort(int[] a, int n) {
  if (n <= 1) return;

  for (int i = 1; i < n; ++i) {
    int value = a[i];
    int j = i - 1;
    // 查找插入的位置
    for (; j >= 0; --j) {
      if (a[j] > value) {
        a[j+1] = a[j];  // 数据移动
      } else {
        break;
      }
    }
    a[j+1] = value; // 插入数据
  }
}

```

3. 选择排序如何实现？时间复杂度、空间复杂度、稳定性如何？
    - 实现
        - 也是分已排序区间和未排序区间，然后从未排序区间里找到最小的元素，将其放到已排序区间的末尾
    - 时间复杂度
        - 最好：O(n2)
        - 最坏：O(n2)
        - 平均：O(n2)
    - 空间复杂度
        - O(1)
    - 稳定性
        - 不稳定，交换的时候可能将后面的元素交换到前面去了。

4. 冒泡排序和插入排序的实际复杂度都是O(n2)，为什么插入排序比冒泡排序更受欢迎？
    - 在内层循环里面，冒泡排序需要进行交换，有三个赋值的动作，而插入排序只有一次赋值，所以效率会更高一些。

5. 归并排序如何实现？时间复杂度、空间复杂度、稳定性如何？
    - 实现
        - 先从数组中间分成前后两部分，然后对前后两部分分别排序，再将排序好的两部分合在一起。
        - 主要用到分治思想
    - 时间复杂度
        - 任何情况下都是 ： O(nlogN)
    - 空间复杂度
        - O(n)
    - 稳定性
        - merge的时候，将前面的元素放在前面就能保证是稳定的算法

```Java
//递推公式：
//merge_sort(p…r) = merge(merge_sort(p…q), merge_sort(q+1…r))

//终止条件：
//p >= r 不用再继续分解
// 归并排序算法, A 是数组，n 表示数组大小
merge_sort(A, n) {
  merge_sort_c(A, 0, n-1)
}

// 递归调用函数
merge_sort_c(A, p, r) {
  // 递归终止条件
  if p >= r  then return

  // 取 p 到 r 之间的中间位置 q
  q = (p+r) / 2
  // 分治递归
  merge_sort_c(A, p, q)
  merge_sort_c(A, q+1, r)
  // 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]
  merge(A[p...r], A[p...q], A[q+1...r])
}

```

6. 快速排序如何实现？时间复杂度、空间复杂度、稳定性如何？
    - 实现
        - 找到一个分区点，小的放左边，大的放右边，然后再去处理左边和右边
    - 时间复杂度
        - 最好：O(nLogN),分区均衡
        - 最坏：O(n2),分区不均衡
        - 平均：O(nlogN)
    - 空间复杂度
        - 可以实现原地的快速排序
    - 稳定性
        - 可以实现稳定

```Java
//递推公式：
//quick_sort(p…r) = quick_sort(p…q-1) + quick_sort(q+1, r)

//终止条件：
//p >= r
    public int[] quickSort(int[] array) {
        int[] result = new int[array.length];

        for (int i = 0; i < result.length; i++) {
            result[i] = array[i];
        }

        quickSort(result, 0, result.length - 1);

        return result;
    }

    public void quickSort(int[] array, int start, int end) {

        if (start >= end) {
            return;
        }

        int mid = partition(array, start, end);
        quickSort(array, start, mid - 1);
        quickSort(array, mid + 1, end);
    }

    public int partition(int[] array, int start, int end) {

        int flag = array[end];
        int i = start;
        for (int j = start; j < end; j++) {
            if (array[j] < flag) {

                int temp = array[j];
                array[j] = array[i];
                array[i] = temp;

                i++;
            }
        }

        int temp = array[i];
        array[i] = array[end];
        array[end] = temp;

        return i;
    }
```

7. O(n) 时间复杂度内求无序数组中的第 K 大元素?
    - 可以利用快排的原理，以最后的为分界点，如果右边的数组长度大于K，说明第K大元素就在后面，如果p+1 = k，说明A[p]就是要求解的元素

8. 如果有10个接口访问日志文件，每个日志文件大小约300MB，每个文件里的日志都是按照时间戳从小到大排序的，你希望将这10个较小的日志文件，合并为1一个日志文件，合并之后的日志仍然按照时间戳从小到大排列。如果处理上述排序任务的机器内存只有1GB,有什么解决思路，能快速地将这10个日志文件合并吗？
    - 构建10条io流，每次选出时间戳最小的那条数据写入到新的文件中，一次类推。

9. 桶排序如何实现？时间、空间复杂度、稳定性如何？适合哪些场景？
    - 实现
        - 将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再把每个桶里的数据按照顺序依次取出，组成的序列就是有序的。
    - 适用场景
        - 首先，要排序的数据需要很容易就能划分成m个痛，并且桶与桶之间有天然的大小顺序
        - 其次，数据在各个桶之间的分布是比较均匀的，如果不均匀，会退化为快速排序算范
        - 比较适合用在外部排序，就是数据存储在外部磁盘中，数据量比较大，内存优先，无法将数据全部加载到内存中。
    - 时间复杂度
        - O(n),分到m个桶里，每个桶有K = n/m个元素，桶内快速排序，复杂度为O(klogK) * m = O(nlog(n/m)) == O(n)
    - 空间复杂度
        - 
    - 稳定性 
        - 桶内快排是稳定的，所以可以是稳定的。

10. 有10GB的订单数据，希望按订单金额来排序，但是内存优先，只有几百MB,没办法一次性把10GB的数据都加载到内存中，这个时候应该怎么办？
    - 桶排序，先扫描一遍文件，看看订单金额的数据范围。然后根据订单金额分100个桶或更多，如果一个桶里的数据过多，还可以在桶内再进行桶的划分排序

11. 计数排序如何实现？时间、空间复杂度、稳定性如何？适用于哪些场景中？
    - 实现
        - 计数排序可以说是桶排序的一种特殊情况，要排序的n个数据，所处的范围并不大，每个桶内的数据值都是相同的，省掉了桶内排序的时间
    - 适用场景
        - 只能用在数据范围不大的场景中，如果数据范围k比要排序的数据n大很多，就不适合用基数排序了。而且计数排序只能给非负整数排序，如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下转换为非负整数
    - 时间复杂度
        - O(n)
    - 空间复杂度
    - 稳定性
        - 可以实现稳定。
12. 基数排序如何实现？时间、空间复杂度、稳定性如何？适用于哪些场景中？
    - 实现
    - 适用场景
        - 对要排序的数据是有要求的，需要可以分割出独立的位来比较，而且位之间有递进的关系，如果a数据的高位比b数据大， 那么剩下的地位就不用比较了，初次之外，每一位的数据范围不能太大，要可以用线性排序算法来排序，否则基数排序的时间复杂度就无法做到O(n)了。

13. 假设我们现在需要对D,a,F,B,c,A,z这个字符串进行排序，要求将其中所有小写字母都排在大写字母的前面，但小写字母内部和大写字母内部不要求有序。比如经过排序之后为a,c,z,D,F,B,A，这个如何实现？如果字符串中存储的不仅有大小写字母，还有数字，要将小写字母放前面，大写字母放最后，数字翻中间，不用排序算法，有如何解决？
    - 只有大小写，前后两个指针，前指针找到大写字母，后指针找到小写字母，交换即可。
    - 如果有大小写和数字的话，可以用桶排序了，也可以先小写和非小写，然后再大写和数字

14. Java中的排序函数是用哪种排序算法实现的？
    - Collections.sort()内部还是用的Arrays.sort()来实现的，
    - 元素个数小于47用插入排序
    - 47到286之间，用快速排序，优化的三值取中的优化版本
    - 大于286使用归并排序(这里还有点存疑，TimSort等，看堆排序里怎么说。)

15. 为什么用快速排序而不是归并排序来做基本的排序函数？
    - 归并排序需要额外的内存空间，比如要排序100MB的数据，还需要额外再占用100MB的内存空间，而快速排序可以做到原地排序

16. 如何优化快速排序？
    - 选用合适的分区点
        - 三数取中法，首、尾、中间，分别取出一个数，然后对比大小，取这3个数的中间值作为分区点。
        - 随机法，

#### 第15、16讲 二分查找
1. 什么是二分查找？
    - 实现思路：
        - 针对的是一个有序的数据集合，查找思想有点类似分治思想。每次都通过跟取件中的中间元素对比，将待查找的区间缩小为之前的一般，直到找到要查找的元素，或者区间被缩小为0
    - 时间复杂度
        - O(logN)

2. 二分查找的递归和非递归实现
    - 代码见底部
    - 非递归实现注意三点
        - 循环退出条件是low<=hight，有等号
        - mid取值可以用位运算，防止溢出和优化性能
        - low和high要+1、-1，不然可能发生死循环

3. 二分查找的局限性？
    - 二分查找依赖的是数组，不然无法做到O(1)的情况下取到数值
    - 针对的是有序数据，无序的话，无法做到比较大小判断左右
    - 数据量太大、太小都不适合二分查找，太小可以直接顺序遍历，太大的话，可能没有足够的连续空间来存储用来二分查找的数组。

4. 如何在1000万个整数中快速查找某个整数？
    - 先排序，再利用二分查找算法
    - 不能用散列表或二叉树的原因是，这两者都需要额外的内存空间，而二分查找不需要。

5. 如何变成实现“求一个数的平方根”？要求精确到小数点后6位。
    - 先二分查找求整数，再求小数点后1位，以此类推。

6. 如果用链表存储，二分查找的时间复杂度是多少？为什么用数组而不是二分查找？
    - O(n)，和顺序查找时间复杂度一致，但是比顺序查找还多了一些计算。

7. 二分查找的4种常见变形问题？
    1. 查找第一个值等于给定值的元素
    2. 查找最后一个值等于给定值的元素
    3. 查找第一个大于等于给定值的元素
    4. 查找最后一个大于等于给定值的元素

8. 如何快速定位出一个IP地址的归属地？
    - 现将IP地址转为32位的整型数并排序好，然后用二分查找。

```Java
// 非递归实现
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;

  while (low <= high) {
    int mid = low + ((high - low) >>1);
    if (a[mid] == value) {
      return mid;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return -1;
}
```

```Java
// 递归实现
public int bsearch(int[] a, int n, int val) {
  return bsearchInternally(a, 0, n - 1, val);
}

private int bsearchInternally(int[] a, int low, int high, int value) {
  if (low > high) return -1;

  int mid =  low + ((high - low) >> 1);
  if (a[mid] == value) {
    return mid;
  } else if (a[mid] < value) {
    return bsearchInternally(a, mid+1, high, value);
  } else {
    return bsearchInternally(a, low, mid-1, value);
  }
}

```
```Java
// 变形1：查找第一个值等于给定值的元素
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == 0) || (a[mid - 1] != value)){
        return mid;
      } 
      else {
        high = mid - 1;
      }
    }
  }
  return -1;
}

```
```Java
// 变形2：查找最后一个值等于给定值的元素
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else if (a[mid] < value) {
      low = mid + 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] != value)) {
        return mid;
      }
      else {
        low = mid + 1;
      }
    }
  }
  return -1;
}

```
```Java
// 变形3：查找第一个大于等于给定值的元素
public int bsearch(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] >= value) {
      if ((mid == 0) || (a[mid - 1] < value)) {
        return mid;
      } else {
        high = mid - 1;
      }
    } else {
      low = mid + 1;
    }
  }
  return -1;
}

```
```Java
// 变形4：查找最后一个小于等于给定值的元素
public int bsearch7(int[] a, int n, int value) {
  int low = 0;
  int high = n - 1;
  while (low <= high) {
    int mid =  low + ((high - low) >> 1);
    if (a[mid] > value) {
      high = mid - 1;
    } else {
      if ((mid == n - 1) || (a[mid + 1] > value)) {
        return mid;
      } else {
        low = mid + 1;
      }
    }
  }
  return -1;
}

```

#### 第17讲 跳表(tips：了解即可)
1. 什么是跳表？
    - 链表上加多级索引的结构就是跳表
    - 是一种各方面性能都比较优秀的动态数据结构，可以支持快速的插入、删除、查找操作，甚至可以替代红黑树。
    - Redis中的有序集合(Sorted Set)就是用跳表来实现。

2. 跳表中查询数据的时间/空间复杂度各是多少？
    - 时间复杂度为O(logN)，前提是建立了多级的索引
    - 空间复杂度是O(n)

3. 跳表的插入、删除操作如何实现？时间复杂度是多少？
    - 插入操作，时间复杂度为O(logN)
        - 为了保证链表的有序性，插入操作需要先查找到插入的位置(O(logN))然后进行插入操作(O(1))
    - 删除操作，时间复杂度为O(logN)
        - 删除的时候也是先查找同时拿到前驱结点，然后直接删除。

4. 跳表在插入删除等系列操作后可能会退化为单链表，这个时候如何处理？
    - 进行索引的动态更新
        - 通过随机函数实现。随机函数决定将这个结点插入到哪几级索引中，Rubicon随机函数沙僧城了值K，那么我们就讲这个结点添加到第一级到第K级这K级索引中。随机函数需要保证跳表的索引大小和数据大小平衡性，不至于性能过度退化。

#### 第18、19、20讲 散列表
1. 什么是散列表(Hash Table)？
    - 散列表用的是数组支持按照下标随机访问数据的特性，所以散列表其实就是数组的一种扩展。
    - 通过散列函数将元素的键值映射为下标，然后将数据存储在数组对应下标的位置。当我们按照键值查询元素的时候，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。

2. 如何构造散列函数？
    - 散列函数计算得到的散列值是一个非负整数
    - 如果key1=key2，那么hash(key1) == hash(key2)
    - 如果key1 != key2,那么hash(key1) != hash(key2)

3. 解决散列冲突的两种方法？
    - 开放寻址法
        - 线性探测
            - 如果出现了散列冲突，就重新探测一个空闲位置，将其插入；删除操作的时候，只能标记为delete不然会出错。
        - 二次探测
        - 双重散列
    - 链表法
        - 散列值相同的元素都放在相同槽位中对应的链表中。

4. 如何设计工业级的散列函数？
    - 设计不能太复杂。过于复杂会消耗过多的计算时间
    - 生成的值要尽可能随机并且均匀分布，这样才能避免或者最小化散列冲突。

5. 如何避免低效的扩容？
    - 可以将扩容操作穿插在插入操作的过程中，分批完成。当有新数据要插入的时候，将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，都重复上面的过程，经过多次插入操作之后，老的散列表中嘚瑟护甲就一点一点全部搬移到新散列表中了。

6. 如何选择冲突解决方法？
    - Java中的LinkedHashMap就采用了链表法解决冲突，ThreadLocalMap是通过线性探测的开放寻址法来解决冲突的。
    - 开放寻址：
        - 优点：散列表中的数据都存储在数组中，可以有效地利用cpu缓存加快查询速度。同时序列化比较简单
        - 缺点：删除数据的时候比较麻烦，比起链表法，冲突的代价更高
        - 当数据量比较少、装载因子小的时候，适合用开放寻址法。
    - 链表法：
        - 优点：内存利用率高；对大装载因子的容忍度更高。
        - 缺点：对CPU缓存不友好
        - 适合存储大对象、大数据量的散列表，而且比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。

7. 分析一下HashMap是如何实现的？
    - 初始大小
        - 默认为16，如果事先知道数据量，可以修改默认初始大小，可以减少动态扩容的次数，会提高HashMap的性能
    - 装载因子和动态扩容
        - 最大装载因子默认为0.75，每次扩容为原来的两倍
    - 散列冲突解决方法
        - 链表法解决冲突。在JDK1.8中，当链表长度太长(默认超过8)时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点提高HashMap的性鞥。
    - 散列函数
        - 就是返回对象的hash code

8. LinkedHashMap是如何实现的？
    - 通过双向链表和散列表两种数据结构结合实现的。

#### 第23、24讲 二叉树基础
1. 二叉树中，节点的高度、深度、层数，树的高度各是什么？
    - 节点的高度等于节点到叶子节点的最长路径(边数)
    - 节点的深度等于根节点到这个节点所经历的边的个数
    - 节点的层数等于节点的深度+1
    - 数的高度等于根节点的高度

2. 如何表示(或存储)一棵二叉树？
    - 基于指针或者引用的二叉链表式存储法
        - 节点有三个字段，一个存储数据，一个存指向左子节点的指针，一个存指向右子节点的指针
    - 基于数组的顺序存储法
        - 根节点存储在下标为`i = 1`的位置，则左子节点存储在`2 * i = 2`的位置，右子节点存储在`2 * i + 1 = 3`的位置，以此类推。
        - 适合完全二叉树存储

3. 二叉树的三种遍历方式？
    - 时间复杂度是O(n)，代码见底部

4. 给定一组数据，可以构建出多少种不同的二叉树？
    - N的阶乘
    
5. 什么是二叉查找树？
    - 二叉查找树是为了实现快速查找而生的，二叉查找树要求，在树中的任意一个节点，其左子树中每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值。

6. 二叉查找树的查找、插入、删除操作流程？
    - 查找：
        - 先取根节点，如果它等于target，直接返回
        - 如果target比根节点小，在左子树中递归查找
        - 如果target比根节点大，在右子树中递归查找。
    - 插入：
        - 新插入的数据一般都是在叶子节点的，先查找，然后判断大小插入左子树还是右子树中
    - 删除：
        - 删除的结点没有子节点
            - 直接删除，拿到父节点指向该节点的指针置为null即可
        - 删除的阶段只有一个子节点
            - 将父节点指向该节点的指针指向该节点的子节点
        - 删除的结点有两个子节点 
            - 找到这个节点的右子树中的最小节点，把它替换到要删除的结点上，然后再删除这个最小节点。 

7. 二叉查找树的中序遍历有什么特点？
    - 输出的是有序的数据序列，时间复杂度是O(n)，所以二叉查找树也称为二叉排序树

8. 散列表的插入、删除、查找操作的实际复杂度可以做到常量级的O(1),非常搞笑。而二叉查找树在比较平衡的情况下，插入、删除、查找操作实际复杂度才是O(logN)，相对散列表好像没有什么优势，为什么还要用二叉查找树呢？
    - 散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，进行一遍中序遍历就可以了。可以在O(n)的时间复杂度内输出。
    - 散列表扩容耗时很多，而且遇到散列冲突时，性能不稳定。而常用的平衡二叉树的性能非常稳定，时间复杂度稳定在O(logN)
    - 尽管散列表的查找等操作的实际复杂度是常量级的，但是因为哈希冲突的存在，这个常量不一定比logN小，所以实际的查找时间不一定比O(logN)快，加上哈希函数的耗时，不一定比平衡二叉树的效率高。
    - 散列表的构造比二叉查找树要复杂，需要考虑的东西很多，如散列函数的设计、冲突解决方法、扩容、缩容等。而平衡二叉查找树只需要考虑平衡性这一个问题。
    - 为了避免过多的散列冲突，散列表装载因子不能太大，不然会浪费一定的存储空间。

```Java
void preOrder(Node* root) {
  if (root == null) return;
  print root // 此处为伪代码，表示打印 root 节点
  preOrder(root->left);
  preOrder(root->right);
}

void inOrder(Node* root) {
  if (root == null) return;
  inOrder(root->left);
  print root // 此处为伪代码，表示打印 root 节点
  inOrder(root->right);
}

void postOrder(Node* root) {
  if (root == null) return;
  postOrder(root->left);
  postOrder(root->right);
  print root // 此处为伪代码，表示打印 root 节点
}

```

#### 第25、26讲 红黑树
1. 什么是平衡二叉树？什么是平衡二叉查找树？
    - 平衡二叉树要求，二叉树中任意一个节点的左右子树的高度相差不能大于1.
    - 平衡二叉查找树则满足平衡二叉树和二叉查找树两个定义。

2. 什么是红黑树？有什么要求？
    - 红黑树中的节点，一类被标记为黑色，一类被标记为红色，除此之外：
        - 根节点是黑色的
        - 每个叶子节点都是黑色的空节点(NIL)，也就是说叶子节点不存储数据(简化红黑树的代码实现而设置)
        - 任何相邻的结点都不能同时为红色，也就是说红色节点是被黑色节点隔开的。
        - 每个节点，从该节点到达其可达叶子节点的所有路径都包含相同数目的黑色节点。
    - 红黑树的高度近似logN，所以它是近似平衡的，插入、删除、查找操作的时间复杂度都是O(logN)
    - 红黑树是一种性能非常稳定的二叉查找树，所以在工程中，凡是用到动态插入、删除、查找数据的场景，都可以用到它。 
    - 自己实现困难，可以用跳表替换

3. 为什么说红黑树是近似平衡的？
    - 黑色节点取出来，是一个完全四叉树，所以只是多一倍的空间。

4. 动态数据结构支持动态的数据插入、删除、查找操作，除了红黑树，还有哪些？比较一下各自的优势、劣势、应用场景。
    - 散列表
        - O(1),最常用，缺点是不能顺序遍历，及扩容缩容的性能损耗
    - 跳表
        - O(logN)，能顺序遍历，缺点是空间复杂度O(n)，使用不在意内存空间的场景
    - 红黑树
        - O(logN)，中序遍历即顺序遍历，稳定，缺点是难以实现，可以用跳表替换。

5. 如何自己实现一个红黑树？
    - 基本思想：遇到什么样的节点排布，我们就对应怎么去调整
        - 左旋
        - 右旋
    - 插入操作的平衡调整：红黑树规定，插入的节点必须是红色的，而且二叉查找树中新插入的节点都是放在叶子节点上。
        - 如果插入节点的父节点是黑色的，不用调整，满足
        - 如果插入的节点是根节点，直接改变颜色，变成黑色即可。
        - 其他情况：需要做左右旋转和改变颜色，正在处理的节点为关注节点，关注节点会随着迭代而变化，最开始的关注节点是新插入的节点。
            - case1 ：如果关注节点的叔叔节点是红色的
                - 将关注节点的父节点、叔叔节点都设置成黑色
                - 将关注节点的祖父节点设置为红色
                - 关注节点变化为祖父节点
                - 调到case2或case3
            - case2 ：如果关注节点的叔叔节点是黑色的，关注节点是其父节点的右子节点
                - 关注节点变化为父节点
                - 围绕将新的关注节点左旋
                - 调到case3
            - case3 ： 如果关注节点的叔叔节点是黑色，关注节点是其父节点的左子节点
                - 围绕关注节点的祖父节点右旋
                - 将新树中，关注节点的父节点和关注节点的兄弟节点颜色互换
                - 调整结束。
    - 删除操作的平衡调整，分两步
        - 针对删除结点初步调整
        - 针对关注节点进行二次调整
        - 过。有时间有闲心再来背这个吧。
        
#### 第28、29讲 堆和堆排序、堆的应用
1. 堆是怎样的？有什么要求？
    - 堆是一个完全二叉树
    - 堆中每个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。

2. 如何实现一个堆？
    - 往堆中插入一个元素
        - 从下往上堆化
            - 因为每次插入都是插入在堆的最后，每次比较关注节点和父节点，不满足大小关系就互换。
    - 删除堆顶元素
        - 从上往下堆化。删除元素后，先将堆尾元素补充到删除元素位置，然后做从上往下堆化。
    - 往堆中插入、删除堆顶元素的时间复杂度都是O(logN)

3. 如何基于堆实现排序？
    - 时间复杂度为O(nlogN)的原地排序
    - 建堆，时间复杂度是O(n)
        - 从后往前处理数组，每个数据都是从上往下堆化。叶子节点没有子节点，可以从后往前第一个父节点开始堆化。
    - 排序，时间复杂度是O(nlogN)
        - 数组的第一个元素是堆顶，是最小或者最大的元素，将它和n位置的元素互换，然后将前面n-1个元素堆化，继续将第一个和n-1位置的元素互换，一直重复。

4. 为什么在实际开发中，快读排序要比堆排序性能好？
    - 堆排序数据访问的方式没有快速排序友好。堆排序数据是跳着访问的，对CPU缓存不友好
    - 对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。

5. 堆的应用场景？
    - 优先级队列
    - 利用堆求Top K
    - 利用堆求中位数

#### 第30、31讲 图的表示，及深度、广度优先搜索算法
1. 如何理解“图”？
    - 非线性表数据结构
    - 图中的元素叫做顶点，图的一个顶点可以与任意其他顶点建立连接关系，这种建立的关系叫做边。跟顶点相连接的边的条数就是顶点的度。
    - 有方向的图叫做有向图，没有方向的图叫做无向图
    - 有向图中，有多少条表指向这个顶点成为入度；有多少条边是以这个顶点为七店指向其他顶点的，叫做顶点的出度。
    - 每条边都有一个权重的，叫做带权图。

2. 如何在内存中存储图这种数据结构？
    - 邻接矩阵(二维数组)
        - 空间换时间
        - 优点是：存储方式简单、直接，获取两个顶点的关系的时候非常高效；方便计算，可以将很多图的运算转换成矩阵之间的计算。
        - 缺点是：可能比较浪费存储空间
    - 邻接表
        - 时间换空间

3. 广度优先搜索BFS如何实现？
    - 先查找离起始顶点最近的，然后是次近的，一次往外搜索。
    - 时间复杂度：O(V+E),V表示顶点的个数，E表示边的个数
    - 空间复杂度：O(V),V表示顶点的个数

4. 深度优先搜索DFS如何实现？
    - 优先沿着一条路径一直走下去，没有路了再回来找其他的路径，回溯思想。
    - 时间复杂度：O(E),E表示边的个数
    - 空间复杂度：O(V),V表示顶点的个数

```Java
// 广度优先搜索
public void bfs(int s, int t) {
  if (s == t) return;
  boolean[] visited = new boolean[v];
  visited[s]=true;
  Queue<Integer> queue = new LinkedList<>();
  queue.add(s);
  int[] prev = new int[v];
  for (int i = 0; i < v; ++i) {
    prev[i] = -1;
  }
  while (queue.size() != 0) {
    int w = queue.poll();
   for (int i = 0; i < adj[w].size(); ++i) {
      int q = adj[w].get(i);
      if (!visited[q]) {
        prev[q] = w;
        if (q == t) {
          print(prev, s, t);
          return;
        }
        visited[q] = true;
        queue.add(q);
      }
    }
  }
}

private void print(int[] prev, int s, int t) { // 递归打印 s->t 的路径
  if (prev[t] != -1 && t != s) {
    print(prev, s, prev[t]);
  }
  System.out.print(t + " ");
}

```

```Java
// 深度优先搜索
boolean found = false; // 全局变量或者类成员变量

public void dfs(int s, int t) {
  found = false;
  boolean[] visited = new boolean[v];
  int[] prev = new int[v];
  for (int i = 0; i < v; ++i) {
    prev[i] = -1;
  }
  recurDfs(s, t, visited, prev);
  print(prev, s, t);
}

private void recurDfs(int w, int t, boolean[] visited, int[] prev) {
  if (found == true) return;
  visited[w] = true;
  if (w == t) {
    found = true;
    return;
  }
  for (int i = 0; i < adj[w].size(); ++i) {
    int q = adj[w].get(i);
    if (!visited[q]) {
      prev[q] = w;
      recurDfs(q, t, visited, prev);
    }
  }
}

```

#### 第32、33、34讲 字符串匹配基础
1. BF算法(Brute Force算法，暴力匹配算法，朴素匹配算法)
    - 在主串中，检查起始位置分别是0、1、2、3...n-m且长度为m的n-m+1个子串，看有没有跟模式串匹配。
    - 最坏情况下的时间复杂度是O(n*m)
    - 实际开发中是一个常用的字符串匹配算法：
        - 实际开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串的子串匹配的时候，当中图遇到不能匹配的字符的时候，就可以停止了，不需要把m个字符都比对一下。
        - 算法思想简单，代码实现也简单。

2. RK算法(Rabin-Karp算法)
    - 借助哈希算法对BF算法进行改造：通过哈希算法对主串中的n-m+1个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。
    - 时间复杂度：O(n)，极端情况下，大量哈希冲突，退化为O(n*m)
    - 哈希冲突存在，所以可以比较哈希值相等的时候，再对比一下子串和模式串本身就好了。

3. BM算法(Boyer-Moore)算法
    - 非常高效的字符串匹配算法，性能是著名的KMP算法的3到4倍。在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位。主要包括坏字符和好后缀规则。
    - 坏字符规则
        - 从后往前匹配，找到第一个坏字符，然后在模式串中查找这个坏字符，si表示坏字符对应的模式传中字符下标，xi表示坏字符在模式串中存在，这个下标记为xi，如果不存在，则xi为-1，则模式串往后移动的位数就等于si-xi。注意xi以从后往前顺序获取，避免过度滑动。
    - 好后缀规则
        - 已经匹配好的后缀记作{u}，拿它在模式串中查找
            - 如果找到了另外一个匹配的子串{u*}，九江模式串滑动到对齐的位置
            - 如果没有找到，就看好后缀的后缀子串是否存在跟模式串的前缀子串匹配的。有的话就滑动到对齐位置，没有的话，就直接滑动到好后缀的后面
    - 分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的，作为模式串往后滑动的位数。 

4. KMP算法(Knuth Morris Pratt算法) - todo
    - 坏字符
    - 好前缀

#### 第37讲 贪心算法
1. 贪心算法有哪些应用？
    - 霍夫曼编码(Huffman Coding)
    - Prim和Kruskal最小生成树算法
    - Dijkstra单源最短路径算法

2. 如何理解贪心算法？
    - 解题步骤
        - 看到这类问题，首先联想到贪心算法：针对一组数据，定义了限制值和期望值，希望从中选出几个数据，在满足限制值的情况下，期望值最大
        - 尝试看下这个问题是否可以用贪心算法解决：每次选择当前情况下，在对限制值同等贡献量的情况下，对期望值贡献最大的数据
        - 举几个例子看下贪心算法产生的结果是否是最优的。
    - 用贪心算法解决问题的思路，并不总能给出最优解。如果前面的选择会影响后面的选择，这种情况下，贪心算法就不能给出最优解了。

3. 举例说明一下是如何运用贪心算法的？
    - 分糖果
        - 期望值是满足需求的人数越多，限制值是一定的糖果总量。可以优先满足需求低的。
    - 钱币找零
        - 限制值是纸币面值一定，期望值是张数越少。可以优先用面值大的，然后继续用面值小的。
    - 区间覆盖
        - 假设这n个区间中最左端点是lmin，最右是rmax。每次选择的时候，左端点跟前面的已经覆盖的区间不重合，右端点又尽量小的，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。

4. 如何用贪心算法实现霍夫曼编码？
    - 霍夫曼编码是一种有效的编码方法，用于数据压缩中，其压缩率通常在20%~90%之间。
    - 不仅考察文本中有多少个不同字符，还会考察每个字符出现的频率，频率较多的字符用稍微短一些的编码；频率比较少的，用稍微长一些的编码。为了避免解压缩过程中的歧义，霍夫曼编码要求各个字符的编码直接不会出现某个编码是另一个编码前缀的情况。

5. 在一个非负整数a中，我们希望从中移除k个数字，让剩下的数字最小，如何选择移除哪k个数字呢？
    - 由最高位开始，如果低位比它小，则移除它；否则右移一位判断。

6. 假设有n个人等待被服务，但是服务窗口只有一个，每个人需要被服务的时间长度是不同改的，如何安排被服务的先后顺序，才能让这n个人总的等待时间最短？
    - 优先选择服务时间最短的

#### 第38讲 分治算法
1. 如何理解分治算法？
    - 分治算法能解决的问题，一般需要满足以下条件：
        - 原问题与分解成的小问题具有相同的模式
        - 原问题分解成的子问题可以独立求解，子问题之间没有相关性
        - 具有分解终止条件，当问题足够小的时候，可以直接求解
        - 可以将子问题合并成原问题，而这个合并操作的复杂度不能太高，否则就起不到减小算法总体复杂度的效果。
    - 分治算法每层递归都会涉及这样三个操作：
        - 分解：将原问题分解成一系列子问题
        - 解决：递归地求解各个子问题，若子问题足够小，则直接求解
        - 合并：将子问题的结果合并成原问题

#### 第39讲 回溯算法
1. 如何理解回溯算法？
    - 类似枚举搜索：枚举所有的解，找到满足期望的解
2. 回溯算法的经典应用：八皇后问题
    - 依次将8个棋子放到第一行、第二行、第三行。。。第巴行，放置的过程中，不停地检查当前的方法是否满足要求。如果满足，则跳到下一行继续放置；如果不满足，就换一种方法继续尝试。
3. 回溯算法的经典应用：0-1书包问题
    - 将物品依次排列，整个问题就分解成了n个阶段，每个阶段对一个一个物品怎么选择：装进去或者不装进去，然后再递归地处理剩下的物品。
4. 回溯算法的经典应用：正则表达式
    - 依次考察正则表达式中的每个字符，当是非通配符的时候，就直接跟文本的字符进行匹配，如果相同，则继续往下处理；如果不同，则回溯。

```Java
// 八皇后问题
int[] result = new int[8];// 全局或成员变量, 下标表示行, 值表示 queen 存储在哪一列
public void cal8queens(int row) { // 调用方式：cal8queens(0);
  if (row == 8) { // 8 个棋子都放置好了，打印结果
    printQueens(result);
    return; // 8 行棋子都放好了，已经没法再往下递归了，所以就 return
  }
  for (int column = 0; column < 8; ++column) { // 每一行都有 8 中放法
    if (isOk(row, column)) { // 有些放法不满足要求
      result[row] = column; // 第 row 行的棋子放到了 column 列
      cal8queens(row+1); // 考察下一行
    }
  }
}

private boolean isOk(int row, int column) {// 判断 row 行 column 列放置是否合适
  int leftup = column - 1, rightup = column + 1;
  for (int i = row-1; i >= 0; --i) { // 逐行往上考察每一行
    if (result[i] == column) return false; // 第 i 行的 column 列有棋子吗？
    if (leftup >= 0) { // 考察左上对角线：第 i 行 leftup 列有棋子吗？
      if (result[i] == leftup) return false;
    }
    if (rightup < 8) { // 考察右上对角线：第 i 行 rightup 列有棋子吗？
      if (result[i] == rightup) return false;
    }
    --leftup; ++rightup;
  }
  return true;
}

private void printQueens(int[] result) { // 打印出一个二维矩阵
  for (int row = 0; row < 8; ++row) {
    for (int column = 0; column < 8; ++column) {
      if (result[row] == column) System.out.print("Q ");
      else System.out.print("* ");
    }
    System.out.println();
  }
  System.out.println();
}

```

```Java
// 0-1背包问题
public int maxW = Integer.MIN_VALUE; // 存储背包中物品总重量的最大值
// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了；
// w 背包重量；items 表示每个物品的重量；n 表示物品个数
// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：
// f(0, 0, a, 10, 100)
public void f(int i, int cw, int[] items, int n, int w) {
  if (cw == w || i == n) { // cw==w 表示装满了 ;i==n 表示已经考察完所有的物品
    if (cw > maxW) maxW = cw;
    return;
  }
  f(i+1, cw, items, n, w);
  if (cw + items[i] <= w) {// 已经超过可以背包承受的重量的时候，就不要再装了
    f(i+1,cw + items[i], items, n, w);
  }
}

```
```Java
// 正则表达式
public class Pattern {
  private boolean matched = false;
  private char[] pattern; // 正则表达式
  private int plen; // 正则表达式长度

  public Pattern(char[] pattern, int plen) {
    this.pattern = pattern;
    this.plen = plen;
  }

  public boolean match(char[] text, int tlen) { // 文本串及长度
    matched = false;
    rmatch(0, 0, text, tlen);
    return matched;
  }

  private void rmatch(int ti, int pj, char[] text, int tlen) {
    if (matched) return; // 如果已经匹配了，就不要继续递归了
    if (pj == plen) { // 正则表达式到结尾了
      if (ti == tlen) matched = true; // 文本串也到结尾了
      return;
    }
    if (pattern[pj] == '*') { // * 匹配任意个字符
      for (int k = 0; k <= tlen-ti; ++k) {
        rmatch(ti+k, pj+1, text, tlen);
      }
    } else if (pattern[pj] == '?') { // ? 匹配 0 个或者 1 个字符
      rmatch(ti, pj+1, text, tlen);
      rmatch(ti+1, pj+1, text, tlen);
    } else if (ti < tlen && pattern[pj] == text[ti]) { // 纯字符匹配才行
      rmatch(ti+1, pj+1, text, tlen);
    }
  }
}

```
#### 第40讲 动态规划